Binary files duos24/src/compile/build/final.elf and Bootloader/src/compile/build/final.elf differ
diff -ruN duos24/src/compile/build/final.map Bootloader/src/compile/build/final.map
--- duos24/src/compile/build/final.map	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/src/compile/build/final.map	2024-11-18 23:09:25.310012556 +0600
@@ -0,0 +1,478 @@
+
+There are no discarded input sections
+
+Memory Configuration
+
+Name             Origin             Length             Attributes
+FLASH            0x08000000         0x00010000         xr
+SRAM             0x20000000         0x00020000         xrw
+*default*        0x00000000         0xffffffff
+
+Linker script and memory map
+
+LOAD object/kmath.o
+LOAD object/kfloat.o
+LOAD object/cm4.o
+LOAD object/mcu_info.o
+LOAD object/kstring.o
+LOAD object/kmain.o
+LOAD object/stm32_startup.o
+LOAD object/sys_clock.o
+LOAD object/sys_usart.o
+LOAD object/sys_gpio.o
+LOAD object/kstdio.o
+LOAD object/sys_init.o
+LOAD object/unistd.o
+LOAD object/times.o
+LOAD object/serial_lin.o
+LOAD object/UsartRingBuffer.o
+LOAD object/debug.o
+LOAD object/timer.o
+LOAD object/sys_err.o
+LOAD object/sys_rtc.o
+LOAD object/sys_update.o
+LOAD object/flash.o
+LOAD object/crc.o
+
+.text           0x08000000     0x5314
+                0x08000000                        _stext = .
+ *(.isr_vector)
+ .isr_vector    0x08000000      0x1c4 object/stm32_startup.o
+                0x08000000                NVIC_VECTOR
+ *(.text)
+ .text          0x080001c4       0x4e object/kmath.o
+                0x080001c4                __pow
+ *fill*         0x08000212        0x2 
+ .text          0x08000214      0xed4 object/kfloat.o
+                0x08000214                __aeabi_f2d
+                0x080002da                __aeabi_d2f
+                0x08000362                __aeabi_d2iz
+                0x080003f2                __aeabi_d2i
+                0x08000482                get_decimal_part
+                0x0800056c                __aeabi_ui2d
+                0x080005ec                __aeabi_d2uiz
+                0x08000662                __aeabi_dsub
+                0x08000922                __aeabi_dmul
+                0x08000ad4                __aeabi_dadd
+                0x08000d82                __aeabi_d2ulz
+                0x08000e00                __aeabi_ddiv
+                0x080010a8                __aeabi_dcmpeq
+ .text          0x080010e8      0x348 object/cm4.o
+                0x08001154                __SysTick_init
+                0x080011d8                SysTickIntDisable
+                0x080011f8                SysTickIntEnable
+                0x08001218                __SysTick_enable
+                0x08001244                __sysTick_disable
+                0x08001270                __getSysTickCount
+                0x08001288                __updateSysTick
+                0x080012e0                __getTime
+                0x08001314                __get__Second
+                0x0800132c                __get__Minute
+                0x08001344                __get__Hour
+                0x0800135c                SysTick_Handler
+                0x08001390                __enable_fpu
+                0x080013b4                ms_delay
+                0x080013de                getmsTick
+                0x080013ec                wait_until
+                0x0800141e                SYS_SLEEP_WFI
+ .text          0x08001430      0x1a8 object/mcu_info.o
+                0x08001430                show_system_info
+                0x080014dc                store_product_id
+                0x080015c4                get_product_id
+ .text          0x080015d8      0x914 object/kstring.o
+                0x080015d8                __str_to_num
+                0x080016ba                __reverse_str
+                0x08001718                __strlen
+                0x08001746                convert
+                0x080017c4                convertu32
+                0x0800181c                float2str
+                0x080018e8                str2float
+                0x080019ea                kmemset
+                0x08001a36                StrCat
+                0x08001a80                strcopy
+                0x08001aba                clear_str
+                0x08001af8                strncopy
+                0x08001b4a                strn4mcopy
+                0x08001b98                byte_to_hex
+                0x08001c0c                show_byte_hex_str
+                0x08001c4c                show_byte_stream_hex
+                0x08001c8c                strcomp
+                0x08001cdc                strncopy_cmd
+                0x08001d2a                uint16_to_str
+                0x08001e7c                strCat_n_to_m
+ .text          0x08001eec       0x6c object/kmain.o
+                0x08001f08                jump_to_os
+                0x08001f2c                kmain
+ .text          0x08001f58       0xe8 object/stm32_startup.o
+                0x08001f58                Reset_Handler
+                0x08002010                RTC_WKUP_Handler
+                0x08002010                FLASH_Handler
+                0x08002010                DMA2_Stream7_Handler
+                0x08002010                OTG_HS_Handler
+                0x08002010                DMA2_Stream3_Handler
+                0x08002010                USART3_Handler
+                0x08002010                PendSV_Handler
+                0x08002010                NMI_Handler
+                0x08002010                SAI1_Handler
+                0x08002010                TIM6_DAC_Handler
+                0x08002010                CAN1_RX1_Handler
+                0x08002010                EXTI15_10_Handler
+                0x08002010                ADC_Handler
+                0x08002010                I2C1_EV_Handler
+                0x08002010                TAMP_STAMP_Handler
+                0x08002010                I2C3_ER_Handler
+                0x08002010                WWDG_Handler
+                0x08002010                EXTI4_Handler
+                0x08002010                I2C3_EV_Handler
+                0x08002010                DMA1_Stream1_Handler
+                0x08002010                DMA2_Stream4_Handler
+                0x08002010                DMA1_Stream7_Handler
+                0x08002010                OTG_FS_Handler
+                0x08002010                TIM1_BRK_TIM9_Handler
+                0x08002010                I2C1_ER_Handler
+                0x08002010                DMA1_Stream3_Handler
+                0x08002010                UsageFault_Handler
+                0x08002010                TIM1_UP_TIM10_Handler
+                0x08002010                CAN1_RX0_Handler
+                0x08002010                TIM1_CC_Handler
+                0x08002010                I2C2_ER_Handler
+                0x08002010                TIM8_CC_Handler
+                0x08002010                HDMI_CEC_Handler
+                0x08002010                SAI2_Handler
+                0x08002010                CAN1_SCE_Handler
+                0x08002010                DMA1_Stream0_Handler
+                0x08002010                OTG_HS_EP1_OUT_Handler
+                0x08002010                EXTI1_Handler
+                0x08002010                FMC_Handler
+                0x08002010                EXTI3_Handler
+                0x08002010                EXTI2_Handler
+                0x08002010                UART4_Handler
+                0x08002010                CAN2_RX1_Handler
+                0x08002010                EXTI9_5_Handler
+                0x08002010                USART1_Handler
+                0x08002010                CAN2_SCE_Handler
+                0x08002010                TIM3_Handler
+                0x08002010                DMA2_Stream6_Handler
+                0x08002010                Default_Handler
+                0x08002010                DCMI_Handler
+                0x08002010                TIM1_TRG_COM_TIM11_Handler
+                0x08002010                RTC_Alarm_Handler
+                0x08002010                TIM4_Handler
+                0x08002010                TIM8_UP_TIM13_Handler
+                0x08002010                CAN2_TX_Handler
+                0x08002010                SPI2_Handler
+                0x08002010                DMA2_Stream1_Handler
+                0x08002010                DMA1_Stream2_Handler
+                0x08002010                EXTI0_Handler
+                0x08002010                TIM8_BRK_TIM12_Handler
+                0x08002010                CAN2_RX0_Handler
+                0x08002010                DMA2_Stream5_Handler
+                0x08002010                DMA1_Stream6_Handler
+                0x08002010                SDIO_Handler
+                0x08002010                FMPI2C1_ERR_Handler
+                0x08002010                SPI1_Handler
+                0x08002010                I2C2_EV_Handler
+                0x08002010                SPDIF_Rx_Handler
+                0x08002010                DMA2_Stream2_Handler
+                0x08002010                SPI3_Handler
+                0x08002010                DMA2_Stream0_Handler
+                0x08002010                RCC_Handler
+                0x08002010                PVD_Handler
+                0x08002010                UART5_Handler
+                0x08002010                DMA1_Stream5_Handler
+                0x08002010                TIM5_Handler
+                0x08002010                QuadSPI_Handler
+                0x08002010                TIM7_Handler
+                0x08002010                TIM8_TRG_COM_TIM14_Handler
+                0x08002010                CAN1_TX_Handler
+                0x08002010                FPU_Handler
+                0x08002010                FMPI2C1_Handler
+                0x08002010                DMA1_Stream4_Handler
+                0x08002010                DebugMonitor_Handler
+                0x08002010                OTG_HS_WKUP_Handler
+                0x08002010                OTG_FS_WKUP_Handler
+                0x08002010                SPI4_Handler
+                0x08002010                OTG_HS_EP1_IN_Handler
+                0x08002018                HardFault_Handler
+                0x08002020                MemManage_Handler
+                0x08002028                BusFault_Handler
+                0x08002030                SVCall_Handler
+ .text          0x08002040      0x308 object/sys_clock.o
+                0x08002040                __init_sys_clock
+                0x0800210c                __APB1CLK_FREQ
+                0x08002188                __APB2CLK_FREQ
+                0x08002204                __PLL_SYS_CLK
+                0x0800229c                __AHB_CLK
+ .text          0x08002348      0x584 object/sys_usart.o
+                0x080023f8                UART_Init
+                0x08002492                UART_DeInit
+                0x08002500                UART_BRR_SAMPLING16
+                0x08002694                UART_MspInit
+ .text          0x080028cc      0x5bc object/sys_gpio.o
+                0x080028cc                GPIO_WritePin
+                0x080028fe                GPIO_Init
+                0x08002c04                GPIO_DeInit
+                0x08002dec                SPI_GPIOInit
+ .text          0x08002e88      0x35c object/kstdio.o
+                0x08002e88                kprintf
+                0x0800301c                putstr
+                0x08003068                kscanf
+ .text          0x080031e4      0x14c object/sys_init.o
+                0x08003270                __sys_init
+                0x080032c8                __sys_disable
+                0x08003310                SYS_ROUTINE
+                0x0800331c                display_status
+ .text          0x08003330        0x0 object/unistd.o
+ .text          0x08003330        0x0 object/times.o
+ .text          0x08003330      0x1b8 object/serial_lin.o
+                0x08003330                SerialLin2_init
+                0x080033c8                SerialLin6_init
+                0x08003460                USART2_Handler
+                0x08003474                USART6_Handler
+                0x08003488                noIntWrite
+                0x080034b8                noIntSendString
+ .text          0x080034e8      0xc38 object/UsartRingBuffer.o
+                0x080034e8                Ringbuf_init
+                0x08003582                Look_for
+                0x08003622                GetDataFromBuffer
+                0x08003762                Uart_flush
+                0x0800379e                Uart_peek
+                0x08003818                Uart_read
+                0x080038b8                Uart_write
+                0x08003970                IsDataAvailable
+                0x080039f4                Get_after
+                0x08003a52                Uart_sendstring
+                0x08003a80                Uart_printbase
+                0x08003b18                Copy_upto
+                0x08003c18                Wait_for
+                0x08003d04                look_for_frame
+                0x08003e6a                Uart_isr
+                0x08003f78                update_tail
+                0x08003fde                debug_buffer
+                0x08004064                DisableUart
+ .text          0x08004120      0x110 object/debug.o
+                0x08004120                __debugRamUsage
+                0x0800416c                __digitalWriteDebugButton
+                0x080041c8                __digitalReadDebugButton
+                0x080041f8                __alalogReadDebug
+                0x08004210                __analogWriteDebug
+ .text          0x08004230      0x2b8 object/timer.o
+                0x080042b0                ConfigTimer2ForSystem
+                0x0800432c                Delay_micro_second
+                0x080043c0                Delay
+                0x080043ee                getMiliseconds
+                0x08004430                getMicroseconds
+                0x08004460                TIM2_Handler
+                0x0800449c                DisableTimer2
+ .text          0x080044e8       0x14 object/sys_err.o
+                0x080044e8                Error_Handler
+ .text          0x080044fc      0x364 object/sys_rtc.o
+                0x080044fc                SYS_RTC_init
+                0x080047a4                get_timeofDay
+ .text          0x08004860      0x410 object/sys_update.o
+                0x08004860                reset_version
+                0x08004880                system_update
+                0x08004896                compare_strings
+                0x080048fc                check_version
+                0x08004984                char_array_to_int
+                0x080049e6                fetch_update
+ .text          0x08004c70      0x374 object/flash.o
+                0x08004c70                flash_unlock
+                0x08004ca0                flash_lock
+                0x08004cc0                flash_erase
+                0x08004d48                flash_erase_check
+                0x08004d82                flash_byte_write
+                0x08004dfc                flash_write
+                0x08004f70                flash_byte_read
+                0x08004f8c                flash_read
+ .text          0x08004fe4       0x80 object/crc.o
+                0x08004fe4                CRC_Config
+                0x0800500c                CRC_Reset
+                0x08005024                CRC_Calc
+ *(.rodata)
+ .rodata        0x08005064       0x64 object/mcu_info.o
+ .rodata        0x080050c8        0x6 object/kstring.o
+ *fill*         0x080050ce        0x2 
+ .rodata        0x080050d0       0x11 object/kmain.o
+ *fill*         0x080050e1        0x3 
+ .rodata        0x080050e4        0x4 object/stm32_startup.o
+                0x080050e4                STACK_START
+ .rodata        0x080050e8       0x18 object/sys_clock.o
+                0x080050e8                AHBPrescTable
+                0x080050f8                APBPrescTable
+ .rodata        0x08005100       0x1a object/sys_init.o
+ *fill*         0x0800511a        0x2 
+ .rodata        0x0800511c       0xd4 object/sys_update.o
+ .rodata        0x080051f0      0x122 object/flash.o
+                0x08005314                        . = ALIGN (0x4)
+ *fill*         0x08005312        0x2 
+                0x08005314                        _etext = .
+                0x08005314                        _la_data = LOADADDR (.data)
+
+.glue_7         0x08005314        0x0
+ .glue_7        0x08005314        0x0 linker stubs
+
+.glue_7t        0x08005314        0x0
+ .glue_7t       0x08005314        0x0 linker stubs
+
+.vfp11_veneer   0x08005314        0x0
+ .vfp11_veneer  0x08005314        0x0 linker stubs
+
+.v4_bx          0x08005314        0x0
+ .v4_bx         0x08005314        0x0 linker stubs
+
+.iplt           0x08005314        0x0
+ .iplt          0x08005314        0x0 object/kfloat.o
+
+.rel.dyn        0x08005314        0x0
+ .rel.iplt      0x08005314        0x0 object/kfloat.o
+
+.data           0x20000000       0x6c load address 0x08005314
+                0x20000000                        _sdata = .
+ *(.data)
+ .data          0x20000000        0x0 object/kmath.o
+ .data          0x20000000        0x0 object/kfloat.o
+ .data          0x20000000        0x0 object/cm4.o
+ .data          0x20000000        0x0 object/mcu_info.o
+ .data          0x20000000       0x61 object/kstring.o
+ .data          0x20000061        0x0 object/kmain.o
+ .data          0x20000061        0x0 object/stm32_startup.o
+ .data          0x20000061        0x0 object/sys_clock.o
+ .data          0x20000061        0x0 object/sys_usart.o
+ .data          0x20000061        0x0 object/sys_gpio.o
+ .data          0x20000061        0x0 object/kstdio.o
+ .data          0x20000061        0x0 object/sys_init.o
+ .data          0x20000061        0x0 object/unistd.o
+ .data          0x20000061        0x0 object/times.o
+ *fill*         0x20000061        0x3 
+ .data          0x20000064        0x8 object/serial_lin.o
+                0x20000064                errObj
+ .data          0x2000006c        0x0 object/UsartRingBuffer.o
+ .data          0x2000006c        0x0 object/debug.o
+ .data          0x2000006c        0x0 object/timer.o
+ .data          0x2000006c        0x0 object/sys_err.o
+ .data          0x2000006c        0x0 object/sys_rtc.o
+ .data          0x2000006c        0x0 object/sys_update.o
+ .data          0x2000006c        0x0 object/flash.o
+ .data          0x2000006c        0x0 object/crc.o
+                0x2000006c                        . = ALIGN (0x4)
+                0x2000006c                        _edata = .
+
+.igot.plt       0x2000006c        0x0 load address 0x08005380
+ .igot.plt      0x2000006c        0x0 object/kfloat.o
+
+.bss            0x2000006c    0x18fad load address 0x08005380
+                0x2000006c                        _sbss = .
+ *(.bss)
+ .bss           0x2000006c        0x0 object/kmath.o
+ .bss           0x2000006c        0x0 object/kfloat.o
+ .bss           0x2000006c       0x10 object/cm4.o
+ .bss           0x2000007c       0x14 object/mcu_info.o
+ .bss           0x20000090       0x32 object/kstring.o
+ .bss           0x200000c2        0x0 object/kmain.o
+ *fill*         0x200000c2        0x2 
+ .bss           0x200000c4        0xc object/stm32_startup.o
+                0x200000c4                _bss_size
+                0x200000c8                _data_size
+                0x200000cc                _text_size
+ .bss           0x200000d0        0x0 object/sys_clock.o
+ .bss           0x200000d0        0x0 object/sys_usart.o
+ .bss           0x200000d0        0x0 object/sys_gpio.o
+ .bss           0x200000d0        0x0 object/kstdio.o
+ .bss           0x200000d0        0x0 object/sys_init.o
+ .bss           0x200000d0        0x0 object/unistd.o
+ .bss           0x200000d0        0x0 object/times.o
+ .bss           0x200000d0      0x890 object/serial_lin.o
+                0x200000d0                huart2
+                0x20000518                huart6
+ .bss           0x20000960        0x0 object/UsartRingBuffer.o
+ .bss           0x20000960        0xc object/debug.o
+                0x20000964                CURRENT_MSP
+                0x20000968                DEBUG_BUTTON
+                0x2000096a                DEBUG_ANALOG_IO
+ .bss           0x2000096c        0x5 object/timer.o
+ .bss           0x20000971        0x0 object/sys_err.o
+ .bss           0x20000971        0x0 object/sys_rtc.o
+ *fill*         0x20000971        0x3 
+ .bss           0x20000974    0x186a5 object/sys_update.o
+                0x20000974                updated_os
+ .bss           0x20019019        0x0 object/flash.o
+ .bss           0x20019019        0x0 object/crc.o
+                0x20019019                        _ebss = .
+OUTPUT(build/final.elf elf32-littlearm)
+LOAD linker stubs
+
+.comment        0x00000000       0x26
+ .comment       0x00000000       0x26 object/kmath.o
+                                 0x27 (size before relaxing)
+ .comment       0x00000026       0x27 object/kfloat.o
+ .comment       0x00000026       0x27 object/cm4.o
+ .comment       0x00000026       0x27 object/mcu_info.o
+ .comment       0x00000026       0x27 object/kstring.o
+ .comment       0x00000026       0x27 object/kmain.o
+ .comment       0x00000026       0x27 object/stm32_startup.o
+ .comment       0x00000026       0x27 object/sys_clock.o
+ .comment       0x00000026       0x27 object/sys_usart.o
+ .comment       0x00000026       0x27 object/sys_gpio.o
+ .comment       0x00000026       0x27 object/kstdio.o
+ .comment       0x00000026       0x27 object/sys_init.o
+ .comment       0x00000026       0x27 object/unistd.o
+ .comment       0x00000026       0x27 object/times.o
+ .comment       0x00000026       0x27 object/serial_lin.o
+ .comment       0x00000026       0x27 object/UsartRingBuffer.o
+ .comment       0x00000026       0x27 object/debug.o
+ .comment       0x00000026       0x27 object/timer.o
+ .comment       0x00000026       0x27 object/sys_err.o
+ .comment       0x00000026       0x27 object/sys_rtc.o
+ .comment       0x00000026       0x27 object/sys_update.o
+ .comment       0x00000026       0x27 object/flash.o
+ .comment       0x00000026       0x27 object/crc.o
+
+.ARM.attributes
+                0x00000000       0x32
+ .ARM.attributes
+                0x00000000       0x32 object/kmath.o
+ .ARM.attributes
+                0x00000032       0x32 object/kfloat.o
+ .ARM.attributes
+                0x00000064       0x32 object/cm4.o
+ .ARM.attributes
+                0x00000096       0x32 object/mcu_info.o
+ .ARM.attributes
+                0x000000c8       0x32 object/kstring.o
+ .ARM.attributes
+                0x000000fa       0x32 object/kmain.o
+ .ARM.attributes
+                0x0000012c       0x32 object/stm32_startup.o
+ .ARM.attributes
+                0x0000015e       0x32 object/sys_clock.o
+ .ARM.attributes
+                0x00000190       0x32 object/sys_usart.o
+ .ARM.attributes
+                0x000001c2       0x32 object/sys_gpio.o
+ .ARM.attributes
+                0x000001f4       0x32 object/kstdio.o
+ .ARM.attributes
+                0x00000226       0x32 object/sys_init.o
+ .ARM.attributes
+                0x00000258       0x32 object/unistd.o
+ .ARM.attributes
+                0x0000028a       0x32 object/times.o
+ .ARM.attributes
+                0x000002bc       0x32 object/serial_lin.o
+ .ARM.attributes
+                0x000002ee       0x32 object/UsartRingBuffer.o
+ .ARM.attributes
+                0x00000320       0x32 object/debug.o
+ .ARM.attributes
+                0x00000352       0x32 object/timer.o
+ .ARM.attributes
+                0x00000384       0x32 object/sys_err.o
+ .ARM.attributes
+                0x000003b6       0x32 object/sys_rtc.o
+ .ARM.attributes
+                0x000003e8       0x32 object/sys_update.o
+ .ARM.attributes
+                0x0000041a       0x32 object/flash.o
+ .ARM.attributes
+                0x0000044c       0x32 object/crc.o
diff -ruN duos24/src/compile/Makefile Bootloader/src/compile/Makefile
--- duos24/src/compile/Makefile	2024-09-30 23:22:59.000000000 +0600
+++ Bootloader/src/compile/Makefile	2024-11-18 23:02:12.845551798 +0600
@@ -73,7 +73,10 @@
 sys_spi.o \
 sys_err.o \
 sys_rtc.o \
-duos \
+sys_update.o \
+flash.o \
+crc.o \
+bootloader \
 final.elf
 
 
@@ -141,6 +144,15 @@
 UsartRingBuffer.o: $(OS_PATH)/lib/UsartRingBuffer.c
 	$(CC) $(CFLAGS) $(INCLUDE) $^ -o $(OBJECT)/$@
 
+flash.o: $(OS_PATH)/lib/flash.c
+	$(CC) $(CFLAGS) $(INCLUDE) $^ -o $(OBJECT)/$@
+
+crc.o: $(OS_PATH)/lib/crc.c
+	$(CC) $(CFLAGS) $(INCLUDE) $^ -o $(OBJECT)/$@
+
+sys_update.o: $(OS_PATH)/lib/sys_update.c
+	$(CC) $(CFLAGS) $(INCLUDE) $^ -o $(OBJECT)/$@
+
 debug.o:$(OS_PATH)/lib/sotom/debug.c
 	$(CC) $(CFLAGS) $(INCLUDE) $^ -o $(OBJECT)/$@
 
@@ -159,7 +171,7 @@
 test_can.o: $(USERLAND)/utils/test_can.c
 	$(CC) $(CFLAGS) $(INCLUDE) $^ -o $(OBJECT)/$@
 
-duos: $(OBJECT)/kmath.o \
+bootloader: $(OBJECT)/kmath.o \
 	$(OBJECT)/kfloat.o  \
 	$(OBJECT)/cm4.o \
 	$(OBJECT)/mcu_info.o \
@@ -178,7 +190,10 @@
 	$(OBJECT)/debug.o \
 	$(OBJECT)/timer.o \
 	$(OBJECT)/sys_err.o \
-	$(OBJECT)/sys_rtc.o  
+	$(OBJECT)/sys_rtc.o \
+	$(OBJECT)/sys_update.o \
+	$(OBJECT)/flash.o \
+	$(OBJECT)/crc.o
 	
 
 	$(CC) $(LDFLAGS) $^ -o $(TARGET)/$@
@@ -205,7 +220,10 @@
 	$(OBJECT)/debug.o \
 	$(OBJECT)/timer.o \
 	$(OBJECT)/sys_err.o \
-	$(OBJECT)/sys_rtc.o 
+	$(OBJECT)/sys_rtc.o \
+	$(OBJECT)/sys_update.o \
+	$(OBJECT)/flash.o \
+	$(OBJECT)/crc.o
 	
 	
 	$(CC) $(LDFLAGS) $^ -o build/$@
@@ -216,7 +234,5 @@
 clean:
 	rm -rf $(OBJECT)/*.o $(MAPDIR)/*.map $(TARGET)/* *.o *.elf build/*
 
-# To Students -- Modify to match with the appropriate driver file.
 load:
-	openocd -f /usr/share/openocd/scripts/board/stm32f4discovery.cfg -f /usr/share/openocd/scripts/interface/stlink.cfg -c "program target/duos verify reset exit"
-
+	openocd -f /usr/share/openocd/scripts/board/stm32f4discovery.cfg -f /usr/share/openocd/scripts/interface/stlink.cfg -c "program target/bootloader verify reset exit"
Binary files duos24/src/compile/object/cm4.o and Bootloader/src/compile/object/cm4.o differ
Binary files duos24/src/compile/object/crc.o and Bootloader/src/compile/object/crc.o differ
Binary files duos24/src/compile/object/debug.o and Bootloader/src/compile/object/debug.o differ
Binary files duos24/src/compile/object/flash.o and Bootloader/src/compile/object/flash.o differ
Binary files duos24/src/compile/object/kfloat.o and Bootloader/src/compile/object/kfloat.o differ
Binary files duos24/src/compile/object/kmain.o and Bootloader/src/compile/object/kmain.o differ
Binary files duos24/src/compile/object/kmath.o and Bootloader/src/compile/object/kmath.o differ
Binary files duos24/src/compile/object/kstdio.o and Bootloader/src/compile/object/kstdio.o differ
Binary files duos24/src/compile/object/kstring.o and Bootloader/src/compile/object/kstring.o differ
Binary files duos24/src/compile/object/ktimes.o and Bootloader/src/compile/object/ktimes.o differ
Binary files duos24/src/compile/object/kunistd.o and Bootloader/src/compile/object/kunistd.o differ
Binary files duos24/src/compile/object/mcu_info.o and Bootloader/src/compile/object/mcu_info.o differ
Binary files duos24/src/compile/object/serial_lin.o and Bootloader/src/compile/object/serial_lin.o differ
Binary files duos24/src/compile/object/stm32_startup.o and Bootloader/src/compile/object/stm32_startup.o differ
Binary files duos24/src/compile/object/syscall.o and Bootloader/src/compile/object/syscall.o differ
Binary files duos24/src/compile/object/sys_clock.o and Bootloader/src/compile/object/sys_clock.o differ
Binary files duos24/src/compile/object/sys_err.o and Bootloader/src/compile/object/sys_err.o differ
Binary files duos24/src/compile/object/sys_gpio.o and Bootloader/src/compile/object/sys_gpio.o differ
Binary files duos24/src/compile/object/sys_init.o and Bootloader/src/compile/object/sys_init.o differ
Binary files duos24/src/compile/object/sys_rtc.o and Bootloader/src/compile/object/sys_rtc.o differ
Binary files duos24/src/compile/object/sys_spi.o and Bootloader/src/compile/object/sys_spi.o differ
Binary files duos24/src/compile/object/sys_timer.o and Bootloader/src/compile/object/sys_timer.o differ
Binary files duos24/src/compile/object/sys_update.o and Bootloader/src/compile/object/sys_update.o differ
Binary files duos24/src/compile/object/sys_usart.o and Bootloader/src/compile/object/sys_usart.o differ
Binary files duos24/src/compile/object/timer.o and Bootloader/src/compile/object/timer.o differ
Binary files duos24/src/compile/object/times.o and Bootloader/src/compile/object/times.o differ
Binary files duos24/src/compile/object/unistd.o and Bootloader/src/compile/object/unistd.o differ
Binary files duos24/src/compile/object/UsartRingBuffer.o and Bootloader/src/compile/object/UsartRingBuffer.o differ
Binary files duos24/src/compile/target/bootloader and Bootloader/src/compile/target/bootloader differ
diff -ruN duos24/src/kern/arch/include/cm4/cm4.h Bootloader/src/kern/arch/include/cm4/cm4.h
--- duos24/src/kern/arch/include/cm4/cm4.h	2024-09-28 11:53:44.000000000 +0600
+++ Bootloader/src/kern/arch/include/cm4/cm4.h	2024-10-26 16:39:17.000000000 +0600
@@ -673,6 +673,7 @@
     __NOP();
   }
 }
+
 /**
 * Function related to SysTick
 */
diff -ruN duos24/src/kern/arch/stm32f446re/include/sys_bus_matrix.h Bootloader/src/kern/arch/stm32f446re/include/sys_bus_matrix.h
--- duos24/src/kern/arch/stm32f446re/include/sys_bus_matrix.h	2024-05-29 18:08:01.000000000 +0600
+++ Bootloader/src/kern/arch/stm32f446re/include/sys_bus_matrix.h	2024-11-17 17:54:29.000000000 +0600
@@ -35,6 +35,44 @@
 #endif
 #include <stdint.h>
 
+/** 
+  * @brief CRC calculation unit 
+  */
+#define CRC_BASE	(AHB1PERIPH_BASE + 0x3000UL)
+typedef struct
+{
+  volatile uint32_t DR;         /*!< CRC Data register,             Address offset: 0x00 */
+  volatile uint8_t  IDR;        /*!< CRC Independent data register, Address offset: 0x04 */
+  uint8_t       RESERVED0;  /*!< Reserved, 0x05                                      */
+  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                      */
+  volatile uint32_t CR;         /*!< CRC Control register,          Address offset: 0x08 */
+}CRC_TypeDef;
+
+#define CRC                 ((CRC_TypeDef *) CRC_BASE)
+/******************************************************************************/
+/*                                                                            */
+/*                          CRC calculation unit                              */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for CRC_DR register  *********************/
+#define CRC_DR_DR_Pos       (0U)                                               
+#define CRC_DR_DR_Msk       (0xFFFFFFFFUL << CRC_DR_DR_Pos)                     /*!< 0xFFFFFFFF */
+#define CRC_DR_DR           CRC_DR_DR_Msk                                      /*!< Data register bits */
+
+
+/*******************  Bit definition for CRC_IDR register  ********************/
+#define CRC_IDR_IDR_Pos     (0U)                                               
+#define CRC_IDR_IDR_Msk     (0xFFUL << CRC_IDR_IDR_Pos)                         /*!< 0x000000FF */
+#define CRC_IDR_IDR         CRC_IDR_IDR_Msk                                    /*!< General-purpose 8-bit data register bits */
+
+
+/********************  Bit definition for CRC_CR register  ********************/
+#define CRC_CR_RESET_Pos    (0U)                                               
+#define CRC_CR_RESET_Msk    (0x1UL << CRC_CR_RESET_Pos)                         /*!< 0x00000001 */
+#define CRC_CR_RESET        CRC_CR_RESET_Msk                                   /*!< RESET bit */
+
+
+
 #define CRYSTAL_CLK 8 //8MHz external cystal
 #define HSIRC_CLK 16
 
diff -ruN duos24/src/kern/arch/stm32f446re/linker/linker.ld Bootloader/src/kern/arch/stm32f446re/linker/linker.ld
--- duos24/src/kern/arch/stm32f446re/linker/linker.ld	2023-10-15 15:05:22.000000000 +0600
+++ Bootloader/src/kern/arch/stm32f446re/linker/linker.ld	2024-11-05 00:30:55.000000000 +0600
@@ -1,7 +1,7 @@
 ENTRY(Reset_Handler)
 MEMORY
 {
-	FLASH(RX): ORIGIN = 0x08000000, LENGTH = 512K
+	FLASH(RX): ORIGIN = 0x08000000, LENGTH = 64K
 	SRAM(RWX): ORIGIN = 0x20000000, LENGTH = 128K /* combined both SRAM1 and SRAM2 */
 }
 /* Sections placement in the memory */
diff -ruN duos24/src/kern/dev/include/cmd_def.h Bootloader/src/kern/dev/include/cmd_def.h
--- duos24/src/kern/dev/include/cmd_def.h	2024-09-30 17:51:15.000000000 +0600
+++ Bootloader/src/kern/dev/include/cmd_def.h	2024-11-17 18:41:08.000000000 +0600
@@ -46,7 +46,7 @@
 uint16_t size;
 uint8_t data[64];
 //timestamp to be added
-uint8_t CRC;
+// uint8_t CRC;
 }ecu_mesg_type;
 
 void extract_odb2_cmd(ecu_mesg_type*);
diff -ruN duos24/src/kern/include/crc.h Bootloader/src/kern/include/crc.h
--- duos24/src/kern/include/crc.h	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/src/kern/include/crc.h	2024-11-18 21:48:16.000000000 +0600
@@ -0,0 +1,18 @@
+#ifndef __CRC_H
+#define __CRC_H
+
+#include <stdint.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void CRC_Config(void);
+void CRC_Reset(void);
+uint32_t CRC_Calc(uint8_t *data, uint32_t length);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff -ruN duos24/src/kern/include/flash.h Bootloader/src/kern/include/flash.h
--- duos24/src/kern/include/flash.h	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/src/kern/include/flash.h	2024-11-18 21:48:20.000000000 +0600
@@ -0,0 +1,25 @@
+#ifndef __FLASH_H
+#define __FLASH_H
+
+#include <stdint.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define FLASH_KEY1 0x45670123
+#define FLASH_KEY2 0xCDEF89AB
+
+void flash_unlock(void);
+void flash_lock(void);
+void flash_erase(uint8_t start_sector, uint8_t end_sector);
+int flash_erase_check(uint32_t start_address, uint32_t end_address);
+void flash_byte_write(uint8_t data, uint32_t address);
+void flash_write(uint8_t *data, uint32_t length, uint32_t start_address, uint32_t start_index);
+void flash_read(uint32_t length, uint32_t start_address);
+uint8_t flash_byte_read(uint32_t address);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff -ruN duos24/src/kern/include/kern/sys_init.h Bootloader/src/kern/include/kern/sys_init.h
--- duos24/src/kern/include/kern/sys_init.h	2024-09-24 19:56:33.000000000 +0600
+++ Bootloader/src/kern/include/kern/sys_init.h	2024-11-17 22:06:05.000000000 +0600
@@ -39,6 +39,7 @@
 #define SET_ACT_DEV(QUEUE,DEV)  (QUEUE |= DEV)
 void __sys_init(void); 
 void SoftReset(void);
+void __sys_disable(void);
 uint32_t verify_connectivity(void);
 
 #ifdef __cplusplus
diff -ruN duos24/src/kern/include/sotom/timer.h Bootloader/src/kern/include/sotom/timer.h
--- duos24/src/kern/include/sotom/timer.h	2023-10-27 11:33:43.000000000 +0600
+++ Bootloader/src/kern/include/sotom/timer.h	2024-11-06 22:37:56.000000000 +0600
@@ -20,6 +20,7 @@
 void Delay_micro_second(uint32_t delay);
 uint32_t getMiliseconds(); // can track upto 71days
 uint32_t getMicroseconds(); // upto 1 hour 12 min
+void DisableTimer2(void);
 
 
 #ifdef  __cplusplus
diff -ruN duos24/src/kern/include/sys_update.h Bootloader/src/kern/include/sys_update.h
--- duos24/src/kern/include/sys_update.h	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/src/kern/include/sys_update.h	2024-11-18 21:48:26.000000000 +0600
@@ -0,0 +1,25 @@
+#ifndef __SYS_UPDATE_H
+#define __SYS_UPDATE_H
+
+#include <stdint.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define FLASH_BASE_ADDRESS          (0x08000000U)
+#define VERSION_ADDRESS             (0x08060000U)
+#define BOOTLOADER_SIZE             (0x00010000U) // 64 KB
+#define OS_START_ADDRESS            (FLASH_BASE_ADDRESS + BOOTLOADER_SIZE) // 0X08010000
+#define MAX_SYSTEM_ARRAY_SIZE       100005
+
+void system_update(void);
+int compare_strings(const char *str1, const char *str2);
+int check_version(void);
+int char_array_to_int(const char *str, int n);
+void fetch_update(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff -ruN duos24/src/kern/include/UsartRingBuffer.h Bootloader/src/kern/include/UsartRingBuffer.h
--- duos24/src/kern/include/UsartRingBuffer.h	2024-09-19 16:15:58.000000000 +0600
+++ Bootloader/src/kern/include/UsartRingBuffer.h	2024-11-06 22:37:08.000000000 +0600
@@ -126,6 +126,8 @@
 int32_t update_tail(UART_HandleTypeDef *,uint32_t);
 
 void debug_buffer(UART_HandleTypeDef *);
+
+void DisableUart(UART_HandleTypeDef *huart);
 #ifdef __cplusplus
 }
 #endif
diff -ruN duos24/src/kern/kmain/kmain.c Bootloader/src/kern/kmain/kmain.c
--- duos24/src/kern/kmain/kmain.c	2024-09-30 23:19:01.000000000 +0600
+++ Bootloader/src/kern/kmain/kmain.c	2024-11-18 23:10:49.006347014 +0600
@@ -1,32 +1,3 @@
-/*
- * Copyright (c) 2022
- * Computer Science and Engineering, University of Dhaka
- * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
 
 #include <sys_init.h>
 #include <cm4.h>
@@ -36,12 +7,227 @@
 #include <kstdio.h>
 #include <sys_rtc.h>
 #include <kstring.h>
+#include <sys_update.h>
 #ifndef DEBUG
 #define DEBUG 1
 #endif
+
+// #define FLASH_BASE_ADDRESS          (0x08000000U)
+// #define BOOTLOADER_SIZE             (0x00010000U) // 64 KB
+// #define OS_START_ADDRESS    (FLASH_BASE_ADDRESS + BOOTLOADER_SIZE) // 0X08010000
+
+
+// #define FLASH_KEY1 0x45670123
+// #define FLASH_KEY2 0xCDEF89AB
+
+
+// #define VERSION_ADDR ((volatile uint32_t *)0x2000FFFCU)
+
+static void vector_setup(void){
+    SCB->VTOR = BOOTLOADER_SIZE; 
+}
+
+void jump_to_os(void) {
+    // *VERSION_ADDR = 10;
+
+    typedef void (*void_fn)(void);
+    uint32_t* reset_vector_entry = (uint32_t*)(OS_START_ADDRESS + 4U);
+    uint32_t* reset_vector = (uint32_t*)(*reset_vector_entry);
+    void_fn jump_fn = (void_fn)reset_vector;
+
+    jump_fn();
+}
+
+// void flash_unlock(void){
+ 
+//     if(FLASH->CR & FLASH_CR_LOCK){
+//         FLASH->KEYR = FLASH_KEY1;
+//         FLASH->KEYR = FLASH_KEY2;
+//     }
+// }
+
+
+// void flash_lock(void){
+//     FLASH->CR |= FLASH_CR_LOCK;
+// }
+ 
+// void erase_os_memory_in_flash(){
+ 
+//     /*
+//     sector 4: 0x0801 0000 - 0x0801 FFFF length= 64KB
+//     sector 5: 0x0802 0000 - 0x0803 FFFF length= 128KB
+//     sector 6: 0x0804 0000 - 0x0805 FFFF length= 128KB
+//     sector 7: 0x0806 0000 - 0x0807 FFFF length= 128KB
+ 
+//     */
+ 
+//     flash_unlock();
+ 
+//     for(uint8_t sector=0x4; sector<=0x7; sector++){
+ 
+//         while(FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+ 
+//         FLASH->CR |= FLASH_CR_SER; // Sector erase enabled
+ 
+//         FLASH->CR &= ~(0xF << 3); // Clear the sector number 
+//         FLASH->CR |= sector << 3;   //select the sector to erase in hex
+ 
+//         FLASH->CR |= FLASH_CR_STRT; // start the erase operation
+ 
+//         while(FLASH->SR & FLASH_SR_BSY);
+//     }
+ 
+//     flash_lock();
+// }
+ 
+ 
+// int flash_erased_check(void){
+ 
+//     int start_address = OS_START_ADDRESS;
+//     int end_address = OS_START_ADDRESS + 0x10000U;
+ 
+//     for(int i=start_address; i<end_address; i+=4){
+//         if(*(uint32_t*)i != 0xFFFFFFFF){
+//             return 0;
+//         }
+//     }
+ 
+//     return 1;
+// }
+ 
+ 
+ 
+// void flash_write(uint8_t* data, uint32_t length, uint32_t start_address){
+ 
+//     flash_unlock();
+ 
+//     while(FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+ 
+//     FLASH->CR |= FLASH_CR_PG; // Programming enabled
+ 
+//     for(uint32_t i=0; i<length; i+=1){
+ 
+//         *(uint32_t*)(start_address + i) = *(uint32_t*)(data + i);
+ 
+//         while(FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+//     }
+ 
+//     FLASH->CR &= ~FLASH_CR_PG; // Programming disabled
+ 
+//     flash_lock();
+
+// }
+
+// void flash_write(uint8_t *data, uint32_t length, uint32_t start_address)
+// {
+//     kprintf("write len : %d\n", length);
+//     flash_unlock();
+ 
+//     // Clear previous errors
+//     FLASH->SR |= (FLASH_SR_WRPERR | FLASH_SR_PGAERR | FLASH_SR_PGPERR | FLASH_SR_PGSERR);
+ 
+//     while (FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+ 
+//     FLASH->CR |= FLASH_CR_PG; // Enable programming mode
+ 
+//     for (uint32_t i = 0x1000, j = 0; i < length; i++, j++)
+//     {
+//         // Program byte (8-bit) data to flash
+//         *(uint8_t *)(start_address + j) = data[i];
+ 
+//         while (FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+ 
+//         // Verify the written data
+//         if (*(uint8_t *)(start_address + j) != data[i]) {
+//             kprintf("Verification failed at address 0x%x\n", (start_address + i));
+//             flash_lock();
+//             return;
+//         }
+ 
+//         // Check for errors
+//         if (FLASH->SR & (FLASH_SR_WRPERR | FLASH_SR_PGAERR | FLASH_SR_PGPERR | FLASH_SR_PGSERR))
+//         {
+//             kprintf("Flash write error at index: %d\n", i);
+//             kprintf("SR: 0x%x\n", FLASH->SR);
+//             kprintf("CR: 0x%x\n", FLASH->CR);
+//             kprintf("WRPERR: 0x%x\n", FLASH->SR & FLASH_SR_WRPERR);
+//             kprintf("PGAERR: 0x%x\n", FLASH->SR & FLASH_SR_PGAERR);
+//             kprintf("PGPERR: 0x%x\n", FLASH->SR & FLASH_SR_PGPERR);
+//             kprintf("PGSERR: 0x%x\n", FLASH->SR & FLASH_SR_PGSERR);
+//             FLASH->CR &= ~FLASH_CR_PG; // Disable programming mode
+//             flash_lock();
+//             return; // Exit on error
+//         }
+ 
+//         // kprintf("write index : %d -- address:0x%x\n", i, (uint8_t *)(start_address + i));
+//     }
+ 
+//     FLASH->CR &= ~FLASH_CR_PG; // Programming disabled
+ 
+//     flash_lock();
+// }
+ 
+ 
+// void flash_read(uint8_t* data, uint32_t length, uint32_t start_address){
+ 
+//     for(uint32_t i=0; i<length; i+=4){
+ 
+//         *(uint32_t*)(data + i) = *(uint32_t*)(start_address + i);
+ 
+//         while(FLASH->SR & FLASH_SR_BSY);
+ 
+//     }
+ 
+// }
+
+// void flash_read(uint8_t *data, uint32_t length, uint32_t start_address)
+// {   
+ 
+//     kprintf("read len : %d\n", length);
+ 
+//     for (uint32_t i = 0; i < length; i += 1)
+//     {
+ 
+//         // *(uint8_t *)(data + i) = *(uint8_t *)(start_address + i);
+ 
+//         uint8_t val = *(uint8_t *)(start_address + i);
+ 
+//         kprintf("read : %c --- index : %d --- address : 0x0%x\n", val, i, start_address + i);
+ 
+//         while (FLASH->SR & FLASH_SR_BSY);
+ 
+ 
+//     }
+// }
+
 void kmain(void)
-{
+{   
     __sys_init();
+
+    system_update();
+    // char* updated_os = get_updated_os();
+
+    // ms_delay(1000);
+
+    // flash_erase(0x4, 0x7);
+
+    // kprintf("Erase successful\n");
+    // ms_delay(2000);
+
+    // flash_write(updated_os, get_size(), OS_START_ADDRESS);
+    // ms_delay(2000);
+    // kprintf("Write successful\n");
+
+    // ms_delay(1000);
+
+    // __sys_disable();
+    kprintf("Switching to OS\n");
+
+    vector_setup();
+
+    ms_delay(2000);
+
+    jump_to_os();
     while (1)
     {
       
diff -ruN duos24/src/kern/lib/crc.c Bootloader/src/kern/lib/crc.c
--- duos24/src/kern/lib/crc.c	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/src/kern/lib/crc.c	2024-11-18 21:47:55.000000000 +0600
@@ -0,0 +1,22 @@
+#include <crc.h>
+#include <sys_bus_matrix.h>
+
+void CRC_Config(void) {
+    RCC->AHB1ENR |= RCC_AHB1ENR_CRCEN;
+    CRC->CR = CRC_CR_RESET; // resets the CRC calculation unit to 0xFFFF FFFF
+}
+
+void CRC_Reset(void) {
+    CRC->CR = CRC_CR_RESET; // resets the CRC calculation unit to 0xFFFF FFFF
+}
+
+uint32_t CRC_Calc(uint8_t *data, uint32_t length)
+{
+
+    for (uint32_t i = 0; i < length; i += 1)
+    {
+        CRC->DR = (uint32_t) data[i];
+    }
+
+    return (CRC->DR);
+}
diff -ruN duos24/src/kern/lib/flash.c Bootloader/src/kern/lib/flash.c
--- duos24/src/kern/lib/flash.c	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/src/kern/lib/flash.c	2024-11-18 21:48:00.000000000 +0600
@@ -0,0 +1,153 @@
+#include <flash.h>
+#include <sys_init.h>
+#include <cm4.h>
+#include <kmain.h>
+#include <sys_usart.h>
+#include <kstdio.h>
+#include <sys_rtc.h>
+#include <kstring.h>
+
+void flash_unlock(void){
+ 
+    if(FLASH->CR & FLASH_CR_LOCK){
+        FLASH->KEYR = FLASH_KEY1;
+        FLASH->KEYR = FLASH_KEY2;
+    }
+}
+
+void flash_lock(void){
+    FLASH->CR |= FLASH_CR_LOCK;
+}
+
+void flash_erase(uint8_t start_sector, uint8_t end_sector) {
+ 
+    /*
+    sector 4: 0x0801 0000 - 0x0801 FFFF length= 64KB
+    sector 5: 0x0802 0000 - 0x0803 FFFF length= 128KB
+    sector 6: 0x0804 0000 - 0x0805 FFFF length= 128KB
+    sector 7: 0x0806 0000 - 0x0807 FFFF length= 128KB
+    */
+ 
+    flash_unlock();
+ 
+    for(uint8_t sector=start_sector; sector<=end_sector; sector++){
+ 
+        while(FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+ 
+        FLASH->CR |= FLASH_CR_SER; // Sector erase enabled
+ 
+        FLASH->CR &= ~(0xF << 3); // Clear the sector number 
+        FLASH->CR |= sector << 3;   //select the sector to erase in hex
+ 
+        FLASH->CR |= FLASH_CR_STRT; // start the erase operation
+ 
+        while(FLASH->SR & FLASH_SR_BSY);
+    }
+ 
+    flash_lock();
+}
+
+int flash_erase_check(uint32_t start_address, uint32_t end_address) {
+
+    for(int i=start_address; i<end_address; i+=4){
+        if(*(uint32_t*)i != 0xFFFFFFFF){
+            return 0;
+        }
+    }
+ 
+    return 1;
+}
+
+void flash_byte_write(uint8_t data, uint32_t address) {
+    flash_unlock();
+ 
+    while (FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+ 
+    FLASH->CR |= FLASH_CR_PG; // Enable programming mode
+
+    *(uint8_t *)(address) = data;
+
+    while (FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+
+    if (*(uint8_t *)(address) != data) {
+        kprintf("Verification failed at address 0x%x -- data %c \n", (address), *(uint8_t *)(address));
+        flash_lock();
+        return;
+    }
+ 
+    FLASH->CR &= ~FLASH_CR_PG; // Programming disabled
+
+    flash_lock();
+}
+
+void flash_write(uint8_t *data, uint32_t length, uint32_t start_address, uint32_t start_index)
+{
+    // kprintf("write len : %d\n", length);
+    flash_unlock();
+ 
+    // Clear previous errors
+    FLASH->SR |= (FLASH_SR_WRPERR | FLASH_SR_PGAERR | FLASH_SR_PGPERR | FLASH_SR_PGSERR);
+ 
+    while (FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+ 
+    FLASH->CR |= FLASH_CR_PG; // Enable programming mode
+ 
+    for (uint32_t i = start_index, j = 0; i < length; i++, j++)
+    {
+        // Program byte (8-bit) data to flash
+        *(uint8_t *)(start_address + j) = data[i];
+ 
+        while (FLASH->SR & FLASH_SR_BSY); // Wait for the flash to be ready
+ 
+        // Verify the written data
+        if (*(uint8_t *)(start_address + j) != data[i]) {
+            kprintf("index -- %x data -- %d\n", i, data[i]);
+            kprintf("Verification failed at address 0x%x\n  data  ", (start_address + j), *(uint8_t *)(start_address + j));
+            flash_lock();
+            return;
+        }
+ 
+        // Check for errors
+        if (FLASH->SR & (FLASH_SR_WRPERR | FLASH_SR_PGAERR | FLASH_SR_PGPERR | FLASH_SR_PGSERR))
+        {
+            kprintf("Flash write error at index: %d\n", i);
+            kprintf("SR: 0x%x\n", FLASH->SR);
+            kprintf("CR: 0x%x\n", FLASH->CR);
+            kprintf("WRPERR: 0x%x\n", FLASH->SR & FLASH_SR_WRPERR);
+            kprintf("PGAERR: 0x%x\n", FLASH->SR & FLASH_SR_PGAERR);
+            kprintf("PGPERR: 0x%x\n", FLASH->SR & FLASH_SR_PGPERR);
+            kprintf("PGSERR: 0x%x\n", FLASH->SR & FLASH_SR_PGSERR);
+            FLASH->CR &= ~FLASH_CR_PG; // Disable programming mode
+            flash_lock();
+            return; // Exit on error
+        }
+ 
+        // kprintf("write index : %d -- address:0x%x\n", i, (uint8_t *)(start_address + i));
+    }
+ 
+    FLASH->CR &= ~FLASH_CR_PG; // Programming disabled
+ 
+    flash_lock();
+}
+
+uint8_t flash_byte_read(uint32_t address) {
+    uint8_t val = *(uint8_t *)(address);
+    return val;
+}
+
+void flash_read(uint32_t length, uint32_t start_address)
+{    
+    for (uint32_t i = 0; i < length; i += 1)
+    {
+ 
+        // *(uint8_t *)(data + i) = *(uint8_t *)(start_address + i);
+ 
+        uint8_t val = *(uint8_t *)(start_address + i);
+ 
+        kprintf("read : %c --- index : %d --- address : 0x0%x\n", val, i, start_address + i);
+ 
+        while (FLASH->SR & FLASH_SR_BSY);
+ 
+ 
+    }
+}
diff -ruN duos24/src/kern/lib/kern/sys_init.c Bootloader/src/kern/lib/kern/sys_init.c
--- duos24/src/kern/lib/kern/sys_init.c	2024-10-01 00:33:03.000000000 +0600
+++ Bootloader/src/kern/lib/kern/sys_init.c	2024-11-18 19:12:46.000000000 +0600
@@ -27,7 +27,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
- 
+
 #include <sys_init.h>
 #include <cm4.h>
 #include <sys_clock.h>
@@ -46,6 +46,13 @@
 #endif
 extern UART_HandleTypeDef huart6;
 
+void display_status(void);
+int check_version(void);
+void system_update(void);
+
+// char updated_os[100005];
+// int os_size;
+
 void __sys_init(void)
 {
 	__init_sys_clock(); //configure system clock 180 MHz
@@ -62,19 +69,42 @@
 	ConfigTimer2ForSystem();
 	__ISB();
 	#ifdef DEBUG
-	kprintf("\n************************************\r\n");
-	kprintf("Booting Machine Intelligence System 1.0 .....\r\n");
-	kprintf("Copyright (c) 2024, Prof. Mosaddek Tushar, CSE, DU\r\n");
-	kprintf("CPUID %x\n", SCB->CPUID);
-	kprintf("OS Version: 2024.1.0.0\n");
-	kprintf("Time Elapse %d ms\n",__getTime());
-	kprintf("*************************************\r\n");
-	kprintf("# ");
-	show_system_info();
-	display_group_info();
+	// kprintf("\n************************************\r\n");
+	// kprintf("Booting Machine Intelligence System 1.0 .....\r\n");
+	// kprintf("Copyright (c) 2024, Prof. Mosaddek Tushar, CSE, DU\r\n");
+	// kprintf("CPUID %x\n", SCB->CPUID);
+	// kprintf("OS Version: 2024.1.0.0\n");
+	// kprintf("Time Elapse %d ms\n",__getTime());
+	// kprintf("*************************************\r\n");
+	// kprintf("# ");
+	// show_system_info();
+	display_status();
+    // if (check_version() == 1) {
+    //     system_update();
+    // }
 	#endif
 }
 
+void __sys_disable(void)
+{
+ 
+	// DISABLE ALL PERIPHERALS
+	DisableUart(&huart2);
+	DisableUart(&huart6);
+ 
+	// DISABLE TIMER2
+	DisableTimer2();
+ 
+	// DISABLE ALL INTERRUPTS
+	NVIC_DisableIRQ(USART2_IRQn);
+	NVIC_DisableIRQ(USART6_IRQn);
+	NVIC_DisableIRQ(TIM2_IRQn);
+	NVIC_DisableIRQ(SysTick_IRQn);
+	NVIC_DisableIRQ(FPU_IRQn);
+ 
+	ms_delay(5000);
+}
+
 /*
 * Do not remove it is for debug purpose
 */
@@ -84,12 +114,182 @@
 	__debugRamUsage();
 }
 
-/*
-* Display your Full Name, Registration Number and Class Roll
-* Each line displays a student or group member information
-*/
-void display_group_info(void)
-{
-	kprintf("Empty Group!! -- Update Now\n")
 
+void display_status(void)
+{
+    kprintf("Bootloader is running...\n");
 }
+
+// int compare_strings(const char *str1, const char *str2) {
+//     int i = 0;
+
+//     // Loop through both strings and compare each character
+//     while (str1[i] != '\0' && str2[i] != '\0') {
+//         if (str1[i] != str2[i]) {
+//             return (str1[i] - str2[i]);  // Return difference of first mismatched characters
+//         }
+//         i++;
+//     }
+
+//     return 0;  // Strings are identical
+// }
+
+// int check_version(void) {
+//     kprintf("CHECK_VERSION 1.0\n");
+
+//     char response[50];
+//     int i = 0;
+//     char c = "";
+//     do {
+//         kscanf("%c", &c);
+//         response[i++] = c;
+//     } while (c != '\n');
+
+//     kprintf("%s", response);
+
+//     int ret = compare_strings(response, "UPDATE AVAILABLE");
+
+//     if (ret == 0) {
+//         return 1;
+//     }
+
+//     return 0;
+// }
+
+// int char_array_to_int(const char *str, int n) {
+//     int result = 0;
+//     int i = 0;
+
+//     // Convert each character to an integer
+//     while (i < n) {
+//         // Ensure that the character is a digit (between '0' and '9')
+//         if (str[i] >= '0' && str[i] <= '9') {
+//             result = result * 10 + (str[i] - '0');
+//             // kprintf("%c\n", str[i]);
+//         }
+//         i++;
+//     }
+
+//     return result;
+// }
+
+// // void CRC_Config(void) {
+// //     RCC->AHB1ENR |= RCC_AHB1ENR_CRCEN;
+// //     CRC->CR = CRC_CR_RESET; // resets the CRC calculation unit to 0xFFFF FFFF
+// // }
+
+// // void CRC_Reset(void) {
+// //     CRC->CR = CRC_CR_RESET; // resets the CRC calculation unit to 0xFFFF FFFF
+// // }
+
+// // uint32_t CRC_Calc(uint8_t *data, uint32_t length)
+// // {
+
+// //     for (uint32_t i = 0; i < length; i += 1)
+// //     {
+// //         CRC->DR = (uint32_t) data[i];
+// //     }
+
+// //     return (CRC->DR);
+// // }
+
+
+// void system_update(void) {
+//     kprintf("GET_UPDATE\n");
+
+//     int i = 0;
+//     int file_size = 0;
+
+//     // read file size
+//     char c = "";
+//     char len[10];
+//     int j = 0;
+//     do {
+//         kscanf("%c", &c);
+//         if (c != '$') {
+//             // kprintf("%c\n", c);
+//             len[j++] = c;
+//         }
+//     } while (c != '$');
+//     // kprintf("%d\n", j);
+
+//     file_size = char_array_to_int(len, j);
+//     os_size = file_size;
+
+//     // kprintf("%d\n", file_size);
+//     kprintf("ACK\n");
+
+//     const int CHUNK_SIZE = 500;
+
+//     CRC_Config();
+
+//     // read file chunk by chunk
+//     while (file_size != 0) {
+//         c = "";
+//         int n = CHUNK_SIZE;
+//         if (file_size < CHUNK_SIZE) {
+//             n = file_size;
+//         }
+//         char received_data[n];
+//         for (int k = 0; k < n; k++) {
+//             kscanf("%c", &c);
+//             // updated_os[i++] = c;
+//             received_data[k] = c;
+//         }
+
+//         uint32_t received_crc = 0;
+//         for (int k = 0; k < 4; k++) {
+//             kscanf("%c", &c);
+//             // uint8_t dummy = c;
+//             // kprintf("%x\n", dummy);
+//             received_crc = (received_crc << 8) | (unsigned char)c;  // Combine 4 bytes into a 32-bit integer
+//         }
+
+//         // Compute the CRC32 for the received data
+//         // uint32_t computed_crc = crc32((uint8_t *)received_data, n);
+//         CRC_Reset();
+//         uint32_t computed_crc = CRC_Calc((uint8_t *)received_data, n);
+//         // kprintf("%x\n", received_crc);
+//         // kprintf("%x\n", computed_crc);
+
+//         // Compare the computed CRC with the received CRC
+//         if (computed_crc == received_crc) {
+//             kprintf("ACK\n");
+//             for (int k = 0; k < n; k++) {
+//                 updated_os[i++] = received_data[k];
+//             }
+
+//             if (file_size >= CHUNK_SIZE) {
+//             file_size -= CHUNK_SIZE;
+//             }
+//             else {
+//                 file_size = 0;
+//             }
+//         } else {
+//             kprintf("NACK\n");
+//             break;
+//         }
+
+//         // kprintf("ACK\n");
+//         // kprintf("%d\n", file_size);
+
+//     }
+
+//     if (file_size == 0) {
+//         kprintf("File received successfully\n");
+//     }
+//     else {
+//         kprintf("Error while receiving file\n");
+//     }
+
+//     kprintf("File size %d Bytes\n", os_size);
+//     kprintf("%d\n", i);
+// }
+
+// char* get_updated_os(void) {
+//     return updated_os;
+// }
+
+// int get_size(void) {
+//     return os_size;
+// }
diff -ruN duos24/src/kern/lib/kstdio.c Bootloader/src/kern/lib/kstdio.c
--- duos24/src/kern/lib/kstdio.c	2024-09-08 14:25:52.000000000 +0600
+++ Bootloader/src/kern/lib/kstdio.c	2024-11-17 19:51:11.000000000 +0600
@@ -135,14 +135,19 @@
 			switch (*ptr)
 			{
 			case 'c': //charater
-				*(uint8_t*)va_arg(list,uint8_t*)=Uart_read(__CONSOLE);
+                int input = -1;
+                do {
+                    input = Uart_read(__CONSOLE);
+                } while(input == -1);
+
+				*(uint8_t*)va_arg(list,uint8_t*)=input;
 				break;
 			case 'd': //integer number 
 				//uart_USART_READ_STR(USART2,buff,50); 
 				*(uint32_t*)va_arg(list,uint32_t*)=__str_to_num(buff,10);	
 				break;
 			case 's': //string without spaces
-				//_USART_READ_STR(USART2,buff,50); 
+				// _USART_READ_STR(USART2,buff,50);
 				str = va_arg(list,uint8_t*);
 				len = __strlen(buff);
 				for(int u = 0; u<=len; u++)	// copy from buff to user defined char pointer (i.e string)
diff -ruN duos24/src/kern/lib/sotom/timer.c Bootloader/src/kern/lib/sotom/timer.c
--- duos24/src/kern/lib/sotom/timer.c	2023-10-15 15:30:05.000000000 +0600
+++ Bootloader/src/kern/lib/sotom/timer.c	2024-11-06 22:26:34.000000000 +0600
@@ -90,3 +90,18 @@
   TIM2->CNT = 0;
   SYS_ROUTINE();
 }
+
+void DisableTimer2(void)
+{
+  __NVIC_DisableIRQ(TIM2_IRQn);
+ 
+  TIM2->CR1 &= ~(1 << 0);
+ 
+  TIM2_READY_TO_USE = 0;
+ 
+  TIM2->CNT = 0;
+ 
+  TIM2_INTERRUPT_CALL_COUNT = 0;
+ 
+  RCC->APB1ENR &= ~(1 << 0);
+}
diff -ruN duos24/src/kern/lib/sys_update.c Bootloader/src/kern/lib/sys_update.c
--- duos24/src/kern/lib/sys_update.c	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/src/kern/lib/sys_update.c	2024-11-18 21:48:07.000000000 +0600
@@ -0,0 +1,205 @@
+#include <sys_update.h>
+#include <flash.h>
+#include <crc.h>
+#include <kstdio.h>
+#include <sys_init.h>
+#include <cm4.h>
+
+char updated_os[MAX_SYSTEM_ARRAY_SIZE];
+// int os_size;
+
+void reset_version(void) {
+    char version = '1';
+    flash_byte_write((uint8_t)version, VERSION_ADDRESS);
+}
+
+void system_update(void) {
+    // reset_version();
+    if (check_version() == 1) {
+        fetch_update();
+    }
+}
+
+int compare_strings(const char *str1, const char *str2) {
+    int i = 0;
+
+    // Loop through both strings and compare each character
+    while (str1[i] != '\0' && str2[i] != '\0') {
+        if (str1[i] != str2[i]) {
+            return (str1[i] - str2[i]);  // Return difference of first mismatched characters
+        }
+        i++;
+    }
+
+    return 0;  // Strings are identical
+}
+
+int check_version(void) {
+    uint8_t version = flash_byte_read(VERSION_ADDRESS);
+    // kprintf("%c\n", version);
+    // kprintf("CHECK_VERSION %c\n", version);
+    kprintf("CHECK_VERSION 1\n");
+
+    char response[50];
+    int i = 0;
+    char c;
+    do {
+        kscanf("%c", &c);
+        response[i++] = c;
+    } while (c != '\n');
+
+    // kprintf("%s", response);
+
+    int ret = compare_strings(response, "UPDATE AVAILABLE");
+
+    if (ret == 0) {
+        kscanf("%c", &c);
+        kprintf("Received version %c\n", c);
+        // flash_byte_write((uint8_t)c, VERSION_ADDRESS);
+        // version = flash_byte_read(VERSION_ADDRESS);
+        // kprintf("Version %c\n", version);
+        return 1;
+    }
+
+    return 0;
+}
+
+int char_array_to_int(const char *str, int n) {
+    int result = 0;
+    int i = 0;
+
+    // Convert each character to an integer
+    while (i < n) {
+        // Ensure that the character is a digit (between '0' and '9')
+        if (str[i] >= '0' && str[i] <= '9') {
+            result = result * 10 + (str[i] - '0');
+            // kprintf("%c\n", str[i]);
+        }
+        i++;
+    }
+
+    return result;
+}
+
+void fetch_update(void) {
+    flash_erase(0x4, 0x6);
+    ms_delay(1000);
+
+    kprintf("Flash erase successful\n");
+    kprintf("GET_UPDATE\n");
+
+    int flag = 0;
+    int file_size = 0;
+
+    // read file size
+    char c;
+    char len[10];
+    int j = 0;
+    do {
+        kscanf("%c", &c);
+        if (c != '$') {
+            // kprintf("%c\n", c);
+            len[j++] = c;
+        }
+    } while (c != '$');
+    // kprintf("%d\n", j);
+
+    file_size = char_array_to_int(len, j);
+
+    kprintf("Received file size %d Bytes\n", file_size);
+    kprintf("ACK\n");
+
+    const int CHUNK_SIZE = 500;
+
+    CRC_Config();
+
+    // flash_erase(0x4, 0x7);
+
+    uint32_t start_address = OS_START_ADDRESS;
+
+    int i = 0;
+
+    // read file chunk by chunk
+    while (file_size != 0) {
+        int n = CHUNK_SIZE;
+        if (file_size < CHUNK_SIZE) {
+            n = file_size;
+        }
+        char received_data[n];
+        for (int k = 0; k < n; k++) {
+            kscanf("%c", &c);
+            // updated_os[i++] = c;
+            received_data[k] = c;
+        }
+
+        uint32_t received_crc = 0;
+        for (int k = 0; k < 4; k++) {
+            kscanf("%c", &c);
+            // uint8_t dummy = c;
+            // kprintf("%x\n", dummy);
+            received_crc = (received_crc << 8) | (unsigned char)c;  // Combine 4 bytes into a 32-bit integer
+        }
+
+        // Compute the CRC32 for the received data
+        // uint32_t computed_crc = crc32((uint8_t *)received_data, n);
+        CRC_Reset();
+        uint32_t computed_crc = CRC_Calc((uint8_t *)received_data, n);
+        // kprintf("%x\n", received_crc);
+        kprintf("%x\n", computed_crc);
+
+        // Compare the computed CRC with the received CRC
+        if (computed_crc == received_crc) {
+            for (int k = 0; k < n; k++) {
+                updated_os[i++] = received_data[k];
+            }
+
+            if (MAX_SYSTEM_ARRAY_SIZE - i < CHUNK_SIZE) {
+                if (flag) {
+                    flash_write((uint8_t*)updated_os, i + 1, start_address, 0);
+                }
+                else {
+                    flash_write((uint8_t*)updated_os, i + 1, start_address, 0x1000);
+                    flag = 1;
+                }
+                ms_delay(1000);
+                start_address += (i + 1);
+                i = 0;
+            }
+
+            if (file_size >= CHUNK_SIZE) {
+                file_size -= CHUNK_SIZE;
+            }
+            else {
+                file_size = 0;
+            }
+
+            kprintf("ACK\n");
+            // kprintf("%d\n", file_size);
+        } 
+        else {
+            kprintf("NACK\n");
+            break;
+        }
+
+        // kprintf("ACK\n");
+        // kprintf("%d\n", file_size);
+
+    }
+
+    if (file_size == 0 && i > 0) {
+        if (flag) {
+            flash_write(updated_os, i, start_address, 0);
+        }
+        else {
+            flash_write(updated_os, i, start_address, 0x1000);
+        }
+        ms_delay(2000);
+    }
+
+    if (file_size == 0) {
+        kprintf("File received successfully\n");
+    }
+    else {
+        kprintf("Error while receiving file\n");
+    }
+}
diff -ruN duos24/src/kern/lib/UsartRingBuffer.c Bootloader/src/kern/lib/UsartRingBuffer.c
--- duos24/src/kern/lib/UsartRingBuffer.c	2024-09-20 13:03:09.000000000 +0600
+++ Bootloader/src/kern/lib/UsartRingBuffer.c	2024-11-17 18:46:31.000000000 +0600
@@ -37,6 +37,8 @@
 #include <cm4.h>
 #include <cmd_def.h>
 
+extern UART_HandleTypeDef huart6;
+
 
 /*  Define the device uart and pc uart below according to your setup  */
 
@@ -211,7 +213,7 @@
 		{
 			unsigned char c = uart->pRxBuffPtr->buffer[uart->pRxBuffPtr->tail];
 			uart->pRxBuffPtr->tail = (unsigned int)(uart->pRxBuffPtr->tail + 1) % uart->RxXferSize;
-			return c;
+            return c;
 		}
 	}
 
@@ -489,7 +491,8 @@
 		huart->Instance->SR; /* Read status register */
 
 		c = (unsigned char)(huart->Instance->DR); /* Read data register */
-		store_char(c, huart);					  // store data in buffer
+		// Uart_write(c, huart);
+        store_char(c, huart);					  // store data in buffer
 
 		return;
 	}
@@ -565,3 +568,26 @@
 	}
 }
 
+// added by pekka
+void DisableUart(UART_HandleTypeDef *huart)
+{	
+	//disable uart clock
+	if(huart == &huart2)
+		__RCC_USART2_CLK_DISABLE();
+	else if(huart == &huart6)
+		__RCC_USART6_CLK_DISABLE();
+ 
+ 
+	//disable uart
+	__UART_DISABLE(huart);
+ 
+ 
+	//disable all uart interrupts
+	__UART_DISABLE_IT(huart, UART_IT_PE);
+	__UART_DISABLE_IT(huart, UART_IT_RXNE);
+	__UART_DISABLE_IT(huart, UART_IT_TXE);
+	__UART_DISABLE_IT(huart, UART_IT_ERR);
+	__UART_DISABLE_IT(huart, UART_IT_IDLE);
+	__UART_DISABLE_IT(huart, UART_IT_LBD);
+ 
+}
diff -ruN duos24/.vscode/c_cpp_properties.json Bootloader/.vscode/c_cpp_properties.json
--- duos24/.vscode/c_cpp_properties.json	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/.vscode/c_cpp_properties.json	2024-11-18 23:00:28.708121250 +0600
@@ -0,0 +1,18 @@
+
+//write for linux ubuntu
+{
+    "configurations": [
+        {
+            "name": "Linux",
+            "includePath": [
+                "${workspaceFolder}/**"
+            ],
+            "defines": [],
+            "compilerPath": "/usr/bin/gcc",
+            "cStandard": "c11",
+            "cppStandard": "c++17",
+            "intelliSenseMode": "gcc-x64"
+        }
+    ],
+    "version": 4
+}
\ No newline at end of file
diff -ruN duos24/.vscode/settings.json Bootloader/.vscode/settings.json
--- duos24/.vscode/settings.json	1970-01-01 06:00:00.000000000 +0600
+++ Bootloader/.vscode/settings.json	2024-11-18 18:47:01.000000000 +0600
@@ -0,0 +1,11 @@
+{
+    "files.associations": {
+        "sys_init.h": "c",
+        "sys_bus_matrix.h": "c",
+        "sys_update.h": "c",
+        "sys_usart.h": "c",
+        "kmain.h": "c",
+        "sys_rtc.h": "c",
+        "cm4.h": "c"
+    }
+}
\ No newline at end of file
