diff -ruN duos24/.vscode/settings.json duos24_1/.vscode/settings.json
--- duos24/.vscode/settings.json	1970-01-01 06:00:00.000000000 +0600
+++ duos24_1/.vscode/settings.json	2025-03-16 18:28:22.763020000 +0600
@@ -0,0 +1,20 @@
+{
+  "files.associations": {
+    "syscall.h": "c",
+    "stm32_startup.h": "c",
+    "syscall_def.h": "c",
+    "kunistd.h": "c",
+    "sys_call.h": "c",
+    "cm4.h": "c",
+    "kmain.h": "c",
+    "stdint.h": "c",
+    "kstring.h": "c",
+    "cstdint": "c",
+    "times.h": "c",
+    "unistd.h": "c",
+    "unixtd.h": "c",
+    "stdarg.h": "c",
+    "sys_usart.h": "c",
+    "kstdio.h": "c"
+  }
+}
diff -ruN duos24/src/compile/Makefile duos24_1/src/compile/Makefile
--- duos24/src/compile/Makefile	2025-03-20 15:35:30.066690600 +0600
+++ duos24_1/src/compile/Makefile	2025-03-20 15:34:06.027430000 +0600
@@ -33,7 +33,8 @@
 -mthumb $(FPU) \
 -std=gnu11 \
 -Wall \
--O0
+-O0 \
+-g3
 
 LDFLAGS = -nostdlib \
 -nostartfiles \
@@ -44,7 +45,8 @@
 -T $(OS_PATH)/arch/$(MCU)/linker/linker.ld \
 -Wl,-Map=$(MAPDIR)/duos.map \
 -Wl,-Map=build/final.map \
--O0
+-O0 
+
 
 .PHONY: all clean load
 
@@ -73,6 +75,7 @@
 sys_spi.o \
 sys_err.o \
 sys_rtc.o \
+app.o \
 duos \
 final.elf
 
@@ -159,6 +162,9 @@
 test_can.o: $(USERLAND)/utils/test_can.c
 	$(CC) $(CFLAGS) $(INCLUDE) $^ -o $(OBJECT)/$@
 
+app.o: $(USERLAND)/utils/app.c
+	$(CC) $(CFLAGS) $(INCLUDE) $^ -o $(OBJECT)/$@
+
 duos: $(OBJECT)/kmath.o \
 	$(OBJECT)/kfloat.o  \
 	$(OBJECT)/cm4.o \
@@ -173,12 +179,15 @@
 	$(OBJECT)/sys_init.o \
 	$(OBJECT)/unistd.o \
 	$(OBJECT)/times.o \
+	$(OBJECT)/kunistd.o \
+	$(OBJECT)/syscall.o \
 	$(OBJECT)/serial_lin.o \
 	$(OBJECT)/UsartRingBuffer.o \
 	$(OBJECT)/debug.o \
 	$(OBJECT)/timer.o \
 	$(OBJECT)/sys_err.o \
-	$(OBJECT)/sys_rtc.o  
+	$(OBJECT)/sys_rtc.o \
+	$(OBJECT)/app.o
 	
 
 	$(CC) $(LDFLAGS) $^ -o $(TARGET)/$@
@@ -200,12 +209,15 @@
 	$(OBJECT)/sys_init.o \
 	$(OBJECT)/unistd.o \
 	$(OBJECT)/times.o \
+	$(OBJECT)/kunistd.o \
+	$(OBJECT)/syscall.o \
 	$(OBJECT)/serial_lin.o \
 	$(OBJECT)/UsartRingBuffer.o \
 	$(OBJECT)/debug.o \
 	$(OBJECT)/timer.o \
 	$(OBJECT)/sys_err.o \
-	$(OBJECT)/sys_rtc.o 
+	$(OBJECT)/sys_rtc.o \
+	$(OBJECT)/app.o
 	
 	
 	$(CC) $(LDFLAGS) $^ -o build/$@
@@ -216,7 +228,32 @@
 clean:
 	rm -rf $(OBJECT)/*.o $(MAPDIR)/*.map $(TARGET)/* *.o *.elf build/*
 
-# To Students -- Modify to match with the appropriate driver file.
+# clean_w:
+# 	if exist $(OBJECT)\*.o del /Q $(OBJECT)\*.o
+# 	if exist $(MAPDIR)\*.map del /Q $(MAPDIR)\*.map
+# 	if exist $(TARGET)\* del /Q $(TARGET)\*
+# 	if exist *.o del /Q *.o
+# 	if exist *.elf del /Q *.elf
+# 	if exist build\* del /Q build\*
+
 load:
 	openocd -f /usr/share/openocd/scripts/board/stm32f4discovery.cfg -f /usr/share/openocd/scripts/interface/stlink.cfg -c "program target/duos verify reset exit"
 
+# To Students -- Modify to match with the appropriate driver file.
+# load_w:
+# 	openocd -f C:\OpenOCD-20240916-0.12.0\share\openocd\scripts\board\stm32f4discovery.cfg -f C:\OpenOCD-20240916-0.12.0\share\openocd\scripts\interface\stlink.cfg -c "program target/duos verify reset exit"
+
+#later added fro debug
+small_load:
+	openocd -f /usr/share/openocd/scripts/board/stm32f4discovery.cfg -f /usr/share/openocd/scripts/interface/stlink.cfg 
+
+clean_build:clean all
+gdb:
+	arm-none-eabi-gdb -x init.gdb
+gdb_debug:
+	arm-none-eabi-gdb -x init_debug.gdb
+# go to debug mode using gdb (with clean_build)
+debug_code:clean_build small_load 
+
+run:clean all load  
+# run_w:clean_w all load_w
\ No newline at end of file
Binary files duos24/src/compile/build/final.elf and duos24_1/src/compile/build/final.elf differ
diff -ruN duos24/src/compile/build/final.map duos24_1/src/compile/build/final.map
--- duos24/src/compile/build/final.map	1970-01-01 06:00:00.000000000 +0600
+++ duos24_1/src/compile/build/final.map	2025-03-20 15:32:03.451243600 +0600
@@ -0,0 +1,1334 @@
+
+Discarded input sections
+
+ .group         0x00000000        0xc object/kmath.o
+ .group         0x00000000        0xc object/kmath.o
+ .group         0x00000000        0xc object/kmath.o
+ .group         0x00000000        0xc object/kmath.o
+ .group         0x00000000        0xc object/kmath.o
+ .group         0x00000000        0xc object/kmath.o
+ .group         0x00000000        0xc object/kmath.o
+ .group         0x00000000        0xc object/kfloat.o
+ .group         0x00000000        0xc object/kfloat.o
+ .group         0x00000000        0xc object/kfloat.o
+ .group         0x00000000        0xc object/kfloat.o
+ .group         0x00000000        0xc object/kfloat.o
+ .group         0x00000000        0xc object/kfloat.o
+ .group         0x00000000        0xc object/kfloat.o
+ .group         0x00000000        0xc object/kfloat.o
+ .group         0x00000000        0xc object/kfloat.o
+ .debug_macro   0x00000000      0xa66 object/kfloat.o
+ .debug_macro   0x00000000       0x22 object/kfloat.o
+ .debug_macro   0x00000000       0x8e object/kfloat.o
+ .debug_macro   0x00000000       0x51 object/kfloat.o
+ .debug_macro   0x00000000      0x103 object/kfloat.o
+ .debug_macro   0x00000000       0x6a object/kfloat.o
+ .debug_macro   0x00000000      0x1df object/kfloat.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .group         0x00000000        0xc object/cm4.o
+ .debug_macro   0x00000000      0xa66 object/cm4.o
+ .debug_macro   0x00000000       0x22 object/cm4.o
+ .debug_macro   0x00000000       0x8e object/cm4.o
+ .debug_macro   0x00000000       0x51 object/cm4.o
+ .debug_macro   0x00000000      0x103 object/cm4.o
+ .debug_macro   0x00000000       0x6a object/cm4.o
+ .debug_macro   0x00000000      0x1df object/cm4.o
+ .debug_macro   0x00000000       0x8c object/cm4.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .group         0x00000000        0xc object/mcu_info.o
+ .debug_macro   0x00000000      0xa66 object/mcu_info.o
+ .debug_macro   0x00000000       0x22 object/mcu_info.o
+ .debug_macro   0x00000000       0x8e object/mcu_info.o
+ .debug_macro   0x00000000       0x51 object/mcu_info.o
+ .debug_macro   0x00000000      0x103 object/mcu_info.o
+ .debug_macro   0x00000000       0x6a object/mcu_info.o
+ .debug_macro   0x00000000      0x1df object/mcu_info.o
+ .debug_macro   0x00000000       0x8c object/mcu_info.o
+ .group         0x00000000        0xc object/kstring.o
+ .group         0x00000000        0xc object/kstring.o
+ .group         0x00000000        0xc object/kstring.o
+ .group         0x00000000        0xc object/kstring.o
+ .group         0x00000000        0xc object/kstring.o
+ .group         0x00000000        0xc object/kstring.o
+ .group         0x00000000        0xc object/kstring.o
+ .group         0x00000000        0xc object/kstring.o
+ .group         0x00000000        0xc object/kstring.o
+ .debug_macro   0x00000000      0xa66 object/kstring.o
+ .debug_macro   0x00000000       0x22 object/kstring.o
+ .debug_macro   0x00000000       0x8e object/kstring.o
+ .debug_macro   0x00000000       0x51 object/kstring.o
+ .debug_macro   0x00000000      0x103 object/kstring.o
+ .debug_macro   0x00000000       0x6a object/kstring.o
+ .debug_macro   0x00000000      0x1df object/kstring.o
+ .debug_macro   0x00000000       0x8c object/kstring.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .group         0x00000000        0xc object/kmain.o
+ .debug_macro   0x00000000      0xa66 object/kmain.o
+ .debug_macro   0x00000000       0x22 object/kmain.o
+ .debug_macro   0x00000000       0x8e object/kmain.o
+ .debug_macro   0x00000000       0x51 object/kmain.o
+ .debug_macro   0x00000000      0x103 object/kmain.o
+ .debug_macro   0x00000000       0x6a object/kmain.o
+ .debug_macro   0x00000000      0x1df object/kmain.o
+ .debug_macro   0x00000000       0x8c object/kmain.o
+ .debug_macro   0x00000000       0x66 object/kmain.o
+ .debug_macro   0x00000000      0x75c object/kmain.o
+ .debug_macro   0x00000000       0x9a object/kmain.o
+ .debug_macro   0x00000000     0xd558 object/kmain.o
+ .debug_macro   0x00000000      0x244 object/kmain.o
+ .debug_macro   0x00000000       0x1c object/kmain.o
+ .debug_macro   0x00000000       0x58 object/kmain.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .group         0x00000000        0xc object/stm32_startup.o
+ .debug_macro   0x00000000      0xa66 object/stm32_startup.o
+ .debug_macro   0x00000000       0x22 object/stm32_startup.o
+ .debug_macro   0x00000000       0x8e object/stm32_startup.o
+ .debug_macro   0x00000000       0x51 object/stm32_startup.o
+ .debug_macro   0x00000000      0x103 object/stm32_startup.o
+ .debug_macro   0x00000000       0x6a object/stm32_startup.o
+ .debug_macro   0x00000000      0x1df object/stm32_startup.o
+ .debug_macro   0x00000000     0xd558 object/stm32_startup.o
+ .debug_macro   0x00000000      0x244 object/stm32_startup.o
+ .debug_macro   0x00000000       0x1c object/stm32_startup.o
+ .debug_macro   0x00000000       0x8c object/stm32_startup.o
+ .debug_macro   0x00000000       0x9a object/stm32_startup.o
+ .debug_macro   0x00000000      0x75c object/stm32_startup.o
+ .debug_macro   0x00000000       0x10 object/stm32_startup.o
+ .debug_macro   0x00000000       0x58 object/stm32_startup.o
+ .debug_macro   0x00000000      0x1a1 object/stm32_startup.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .group         0x00000000        0xc object/sys_clock.o
+ .debug_macro   0x00000000      0xa66 object/sys_clock.o
+ .debug_macro   0x00000000       0x22 object/sys_clock.o
+ .debug_macro   0x00000000       0x8e object/sys_clock.o
+ .debug_macro   0x00000000       0x51 object/sys_clock.o
+ .debug_macro   0x00000000      0x103 object/sys_clock.o
+ .debug_macro   0x00000000       0x6a object/sys_clock.o
+ .debug_macro   0x00000000      0x1df object/sys_clock.o
+ .debug_macro   0x00000000     0xd552 object/sys_clock.o
+ .debug_macro   0x00000000       0x16 object/sys_clock.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .group         0x00000000        0xc object/sys_usart.o
+ .debug_macro   0x00000000      0xa66 object/sys_usart.o
+ .debug_macro   0x00000000       0x22 object/sys_usart.o
+ .debug_macro   0x00000000       0x8e object/sys_usart.o
+ .debug_macro   0x00000000       0x51 object/sys_usart.o
+ .debug_macro   0x00000000      0x103 object/sys_usart.o
+ .debug_macro   0x00000000       0x6a object/sys_usart.o
+ .debug_macro   0x00000000      0x1df object/sys_usart.o
+ .debug_macro   0x00000000     0xd552 object/sys_usart.o
+ .debug_macro   0x00000000       0x8c object/sys_usart.o
+ .debug_macro   0x00000000      0x1a1 object/sys_usart.o
+ .debug_macro   0x00000000       0x6c object/sys_usart.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .group         0x00000000        0xc object/sys_gpio.o
+ .debug_macro   0x00000000      0xa66 object/sys_gpio.o
+ .debug_macro   0x00000000       0x22 object/sys_gpio.o
+ .debug_macro   0x00000000       0x8e object/sys_gpio.o
+ .debug_macro   0x00000000       0x51 object/sys_gpio.o
+ .debug_macro   0x00000000      0x103 object/sys_gpio.o
+ .debug_macro   0x00000000       0x6a object/sys_gpio.o
+ .debug_macro   0x00000000      0x1df object/sys_gpio.o
+ .debug_macro   0x00000000     0xd552 object/sys_gpio.o
+ .debug_macro   0x00000000       0x8c object/sys_gpio.o
+ .debug_macro   0x00000000       0xdd object/sys_gpio.o
+ .debug_macro   0x00000000      0x140 object/sys_gpio.o
+ .debug_macro   0x00000000       0x1c object/sys_gpio.o
+ .debug_macro   0x00000000       0x10 object/sys_gpio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .group         0x00000000        0xc object/kstdio.o
+ .debug_macro   0x00000000      0xa66 object/kstdio.o
+ .debug_macro   0x00000000       0x58 object/kstdio.o
+ .debug_macro   0x00000000       0x22 object/kstdio.o
+ .debug_macro   0x00000000       0x8e object/kstdio.o
+ .debug_macro   0x00000000       0x51 object/kstdio.o
+ .debug_macro   0x00000000      0x103 object/kstdio.o
+ .debug_macro   0x00000000       0x6a object/kstdio.o
+ .debug_macro   0x00000000      0x1df object/kstdio.o
+ .debug_macro   0x00000000       0x8c object/kstdio.o
+ .debug_macro   0x00000000     0xd558 object/kstdio.o
+ .debug_macro   0x00000000      0x19b object/kstdio.o
+ .debug_macro   0x00000000      0x201 object/kstdio.o
+ .debug_macro   0x00000000       0x10 object/kstdio.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .group         0x00000000        0xc object/sys_init.o
+ .debug_macro   0x00000000      0xa66 object/sys_init.o
+ .debug_macro   0x00000000       0x22 object/sys_init.o
+ .debug_macro   0x00000000       0x8e object/sys_init.o
+ .debug_macro   0x00000000       0x51 object/sys_init.o
+ .debug_macro   0x00000000      0x103 object/sys_init.o
+ .debug_macro   0x00000000       0x6a object/sys_init.o
+ .debug_macro   0x00000000      0x1df object/sys_init.o
+ .debug_macro   0x00000000       0x8c object/sys_init.o
+ .debug_macro   0x00000000       0x66 object/sys_init.o
+ .debug_macro   0x00000000      0x75c object/sys_init.o
+ .debug_macro   0x00000000     0xd558 object/sys_init.o
+ .debug_macro   0x00000000       0x16 object/sys_init.o
+ .debug_macro   0x00000000      0x1a1 object/sys_init.o
+ .debug_macro   0x00000000      0x140 object/sys_init.o
+ .debug_macro   0x00000000       0x10 object/sys_init.o
+ .debug_macro   0x00000000       0x10 object/sys_init.o
+ .debug_macro   0x00000000       0x3a object/sys_init.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .group         0x00000000        0xc object/unistd.o
+ .debug_macro   0x00000000      0xa66 object/unistd.o
+ .debug_macro   0x00000000       0x22 object/unistd.o
+ .debug_macro   0x00000000       0x8e object/unistd.o
+ .debug_macro   0x00000000       0x51 object/unistd.o
+ .debug_macro   0x00000000      0x103 object/unistd.o
+ .debug_macro   0x00000000       0x6a object/unistd.o
+ .debug_macro   0x00000000      0x1df object/unistd.o
+ .debug_macro   0x00000000       0x8c object/unistd.o
+ .debug_macro   0x00000000      0x244 object/unistd.o
+ .debug_macro   0x00000000       0x58 object/unistd.o
+ .debug_macro   0x00000000       0x6c object/unistd.o
+ .debug_macro   0x00000000      0x75c object/unistd.o
+ .group         0x00000000        0xc object/times.o
+ .group         0x00000000        0xc object/times.o
+ .group         0x00000000        0xc object/times.o
+ .group         0x00000000        0xc object/times.o
+ .group         0x00000000        0xc object/times.o
+ .group         0x00000000        0xc object/times.o
+ .group         0x00000000        0xc object/times.o
+ .group         0x00000000        0xc object/times.o
+ .group         0x00000000        0xc object/times.o
+ .debug_macro   0x00000000      0xa66 object/times.o
+ .debug_macro   0x00000000       0x22 object/times.o
+ .debug_macro   0x00000000       0x8e object/times.o
+ .debug_macro   0x00000000       0x51 object/times.o
+ .debug_macro   0x00000000      0x103 object/times.o
+ .debug_macro   0x00000000       0x6a object/times.o
+ .debug_macro   0x00000000      0x1df object/times.o
+ .debug_macro   0x00000000      0x244 object/times.o
+ .debug_macro   0x00000000       0x8c object/times.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .group         0x00000000        0xc object/kunistd.o
+ .debug_macro   0x00000000      0xa66 object/kunistd.o
+ .debug_macro   0x00000000       0x1c object/kunistd.o
+ .debug_macro   0x00000000       0x22 object/kunistd.o
+ .debug_macro   0x00000000       0x8e object/kunistd.o
+ .debug_macro   0x00000000       0x51 object/kunistd.o
+ .debug_macro   0x00000000      0x103 object/kunistd.o
+ .debug_macro   0x00000000       0x6a object/kunistd.o
+ .debug_macro   0x00000000      0x1df object/kunistd.o
+ .debug_macro   0x00000000       0x8c object/kunistd.o
+ .debug_macro   0x00000000       0x9a object/kunistd.o
+ .debug_macro   0x00000000       0x6c object/kunistd.o
+ .debug_macro   0x00000000      0x75c object/kunistd.o
+ .debug_macro   0x00000000       0x10 object/kunistd.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .group         0x00000000        0xc object/syscall.o
+ .debug_macro   0x00000000      0xa66 object/syscall.o
+ .debug_macro   0x00000000       0x22 object/syscall.o
+ .debug_macro   0x00000000       0x8e object/syscall.o
+ .debug_macro   0x00000000       0x51 object/syscall.o
+ .debug_macro   0x00000000      0x103 object/syscall.o
+ .debug_macro   0x00000000       0x6a object/syscall.o
+ .debug_macro   0x00000000      0x1df object/syscall.o
+ .debug_macro   0x00000000      0x244 object/syscall.o
+ .debug_macro   0x00000000       0x1c object/syscall.o
+ .debug_macro   0x00000000       0x8c object/syscall.o
+ .debug_macro   0x00000000       0x9a object/syscall.o
+ .debug_macro   0x00000000       0x6c object/syscall.o
+ .debug_macro   0x00000000      0x75c object/syscall.o
+ .debug_macro   0x00000000       0x10 object/syscall.o
+ .debug_macro   0x00000000       0x58 object/syscall.o
+ .debug_macro   0x00000000     0xd558 object/syscall.o
+ .debug_macro   0x00000000      0x19b object/syscall.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .group         0x00000000        0xc object/serial_lin.o
+ .debug_macro   0x00000000      0xa66 object/serial_lin.o
+ .debug_macro   0x00000000       0x22 object/serial_lin.o
+ .debug_macro   0x00000000       0x8e object/serial_lin.o
+ .debug_macro   0x00000000       0x51 object/serial_lin.o
+ .debug_macro   0x00000000      0x103 object/serial_lin.o
+ .debug_macro   0x00000000       0x6a object/serial_lin.o
+ .debug_macro   0x00000000      0x1df object/serial_lin.o
+ .debug_macro   0x00000000     0xd552 object/serial_lin.o
+ .debug_macro   0x00000000       0x8c object/serial_lin.o
+ .debug_macro   0x00000000      0x19b object/serial_lin.o
+ .debug_macro   0x00000000       0x10 object/serial_lin.o
+ .debug_macro   0x00000000       0x10 object/serial_lin.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/UsartRingBuffer.o
+ .debug_macro   0x00000000      0xa66 object/UsartRingBuffer.o
+ .debug_macro   0x00000000       0x22 object/UsartRingBuffer.o
+ .debug_macro   0x00000000       0x8e object/UsartRingBuffer.o
+ .debug_macro   0x00000000       0x51 object/UsartRingBuffer.o
+ .debug_macro   0x00000000      0x103 object/UsartRingBuffer.o
+ .debug_macro   0x00000000       0x6a object/UsartRingBuffer.o
+ .debug_macro   0x00000000      0x1df object/UsartRingBuffer.o
+ .debug_macro   0x00000000     0xd552 object/UsartRingBuffer.o
+ .debug_macro   0x00000000       0x8c object/UsartRingBuffer.o
+ .debug_macro   0x00000000      0x19b object/UsartRingBuffer.o
+ .debug_macro   0x00000000       0x6c object/UsartRingBuffer.o
+ .debug_macro   0x00000000       0x10 object/UsartRingBuffer.o
+ .debug_macro   0x00000000      0x762 object/UsartRingBuffer.o
+ .group         0x00000000        0xc object/debug.o
+ .group         0x00000000        0xc object/debug.o
+ .group         0x00000000        0xc object/debug.o
+ .group         0x00000000        0xc object/debug.o
+ .group         0x00000000        0xc object/debug.o
+ .group         0x00000000        0xc object/debug.o
+ .group         0x00000000        0xc object/debug.o
+ .group         0x00000000        0xc object/debug.o
+ .group         0x00000000        0xc object/debug.o
+ .debug_macro   0x00000000      0xa66 object/debug.o
+ .debug_macro   0x00000000       0x22 object/debug.o
+ .debug_macro   0x00000000       0x8e object/debug.o
+ .debug_macro   0x00000000       0x51 object/debug.o
+ .debug_macro   0x00000000      0x103 object/debug.o
+ .debug_macro   0x00000000       0x6a object/debug.o
+ .debug_macro   0x00000000      0x1df object/debug.o
+ .debug_macro   0x00000000       0x2e object/debug.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .group         0x00000000        0xc object/timer.o
+ .debug_macro   0x00000000      0xa66 object/timer.o
+ .debug_macro   0x00000000       0x22 object/timer.o
+ .debug_macro   0x00000000       0x8e object/timer.o
+ .debug_macro   0x00000000       0x51 object/timer.o
+ .debug_macro   0x00000000      0x103 object/timer.o
+ .debug_macro   0x00000000       0x6a object/timer.o
+ .debug_macro   0x00000000      0x1df object/timer.o
+ .debug_macro   0x00000000     0xd558 object/timer.o
+ .debug_macro   0x00000000       0x16 object/timer.o
+ .debug_macro   0x00000000       0x8c object/timer.o
+ .debug_macro   0x00000000       0xdd object/timer.o
+ .debug_macro   0x00000000      0x140 object/timer.o
+ .debug_macro   0x00000000       0x6c object/timer.o
+ .debug_macro   0x00000000      0x75c object/timer.o
+ .group         0x00000000        0xc object/sys_err.o
+ .group         0x00000000        0xc object/sys_err.o
+ .group         0x00000000        0xc object/sys_err.o
+ .group         0x00000000        0xc object/sys_err.o
+ .group         0x00000000        0xc object/sys_err.o
+ .group         0x00000000        0xc object/sys_err.o
+ .group         0x00000000        0xc object/sys_err.o
+ .group         0x00000000        0xc object/sys_err.o
+ .group         0x00000000        0xc object/sys_err.o
+ .debug_macro   0x00000000      0xa66 object/sys_err.o
+ .debug_macro   0x00000000       0x22 object/sys_err.o
+ .debug_macro   0x00000000       0x8e object/sys_err.o
+ .debug_macro   0x00000000       0x51 object/sys_err.o
+ .debug_macro   0x00000000      0x103 object/sys_err.o
+ .debug_macro   0x00000000       0x6a object/sys_err.o
+ .debug_macro   0x00000000      0x1df object/sys_err.o
+ .debug_macro   0x00000000     0xd558 object/sys_err.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .group         0x00000000        0xc object/sys_rtc.o
+ .debug_macro   0x00000000      0xa66 object/sys_rtc.o
+ .debug_macro   0x00000000       0x22 object/sys_rtc.o
+ .debug_macro   0x00000000       0x8e object/sys_rtc.o
+ .debug_macro   0x00000000       0x51 object/sys_rtc.o
+ .debug_macro   0x00000000      0x103 object/sys_rtc.o
+ .debug_macro   0x00000000       0x6a object/sys_rtc.o
+ .debug_macro   0x00000000      0x1df object/sys_rtc.o
+ .debug_macro   0x00000000     0xd558 object/sys_rtc.o
+ .debug_macro   0x00000000       0x10 object/sys_rtc.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .group         0x00000000        0xc object/app.o
+ .debug_macro   0x00000000      0xa66 object/app.o
+ .debug_macro   0x00000000       0x22 object/app.o
+ .debug_macro   0x00000000       0x8e object/app.o
+ .debug_macro   0x00000000       0x51 object/app.o
+ .debug_macro   0x00000000      0x103 object/app.o
+ .debug_macro   0x00000000       0x6a object/app.o
+ .debug_macro   0x00000000      0x1df object/app.o
+ .debug_macro   0x00000000       0x8c object/app.o
+ .debug_macro   0x00000000      0x244 object/app.o
+ .debug_macro   0x00000000       0x58 object/app.o
+ .debug_macro   0x00000000       0x6c object/app.o
+ .debug_macro   0x00000000      0x75c object/app.o
+
+Memory Configuration
+
+Name             Origin             Length             Attributes
+FLASH            0x08000000         0x00080000         xr
+SRAM             0x20000000         0x00020000         xrw
+*default*        0x00000000         0xffffffff
+
+Linker script and memory map
+
+LOAD object/kmath.o
+LOAD object/kfloat.o
+LOAD object/cm4.o
+LOAD object/mcu_info.o
+LOAD object/kstring.o
+LOAD object/kmain.o
+LOAD object/stm32_startup.o
+LOAD object/sys_clock.o
+LOAD object/sys_usart.o
+LOAD object/sys_gpio.o
+LOAD object/kstdio.o
+LOAD object/sys_init.o
+LOAD object/unistd.o
+LOAD object/times.o
+LOAD object/kunistd.o
+LOAD object/syscall.o
+LOAD object/serial_lin.o
+LOAD object/UsartRingBuffer.o
+LOAD object/debug.o
+LOAD object/timer.o
+LOAD object/sys_err.o
+LOAD object/sys_rtc.o
+LOAD object/app.o
+
+.text           0x08000000     0x692c
+                0x08000000                _stext = .
+ *(.isr_vector)
+ .isr_vector    0x08000000      0x1c4 object/stm32_startup.o
+                0x08000000                NVIC_VECTOR
+ *(.text)
+ .text          0x080001c4       0x4e object/kmath.o
+                0x080001c4                __pow
+ *fill*         0x08000212        0x2 
+ .text          0x08000214      0xf10 object/kfloat.o
+                0x08000214                __aeabi_f2d
+                0x080002da                __aeabi_d2f
+                0x08000362                __aeabi_d2iz
+                0x080003f2                __aeabi_d2i
+                0x08000482                get_decimal_part
+                0x0800056c                __aeabi_ui2d
+                0x080005ec                __aeabi_d2uiz
+                0x08000662                __aeabi_dsub
+                0x0800093c                __aeabi_dmul
+                0x08000af2                __aeabi_dadd
+                0x08000dba                __aeabi_d2ulz
+                0x08000e38                __aeabi_ddiv
+                0x080010e4                __aeabi_dcmpeq
+ .text          0x08001124      0x384 object/cm4.o
+                0x08001190                __SysTick_init
+                0x08001214                SysTickIntDisable
+                0x08001234                SysTickIntEnable
+                0x08001254                __SysTick_enable
+                0x08001280                __sysTick_disable
+                0x080012ac                __getSysTickCount
+                0x080012c4                __updateSysTick
+                0x0800131c                __getTime
+                0x08001350                __get__Second
+                0x08001368                __get__Minute
+                0x08001380                __get__Hour
+                0x08001398                SysTick_Handler
+                0x080013e8                __enable_fpu
+                0x0800140c                ms_delay
+                0x08001436                getmsTick
+                0x08001444                wait_until
+                0x08001476                SYS_SLEEP_WFI
+                0x08001486                __set_pending
+ .text          0x080014a8      0x1a8 object/mcu_info.o
+                0x080014a8                show_system_info
+                0x08001554                store_product_id
+                0x0800163c                get_product_id
+ .text          0x08001650      0x91c object/kstring.o
+                0x08001650                __str_to_num
+                0x08001732                __reverse_str
+                0x08001790                __strlen
+                0x080017be                convert
+                0x0800183c                convertu32
+                0x08001894                float2str
+                0x08001960                str2float
+                0x08001a62                kmemset
+                0x08001aae                StrCat
+                0x08001af8                strcopy
+                0x08001b32                clear_str
+                0x08001b70                strncopy
+                0x08001bc2                strn4mcopy
+                0x08001c10                byte_to_hex
+                0x08001c84                show_byte_hex_str
+                0x08001ccc                show_byte_stream_hex
+                0x08001d0c                strcomp
+                0x08001d5c                strncopy_cmd
+                0x08001daa                uint16_to_str
+                0x08001efc                strCat_n_to_m
+ .text          0x08001f6c      0xbf8 object/kmain.o
+                0x08001fd8                RTC_WKUP_Handler
+                0x08001fd8                FLASH_Handler
+                0x08001fd8                OTG_HS_EP1_IN_Handler
+                0x08001fd8                DMA2_Stream7_Handler
+                0x08001fd8                OTG_HS_Handler
+                0x08001fd8                DMA2_Stream3_Handler
+                0x08001fd8                USART3_Handler
+                0x08001fd8                SPI4_Handler
+                0x08001fd8                OTG_FS_WKUP_Handler
+                0x08001fd8                NMI_Handler
+                0x08001fd8                SAI1_Handler
+                0x08001fd8                TIM6_DAC_Handler
+                0x08001fd8                CAN1_RX1_Handler
+                0x08001fd8                EXTI15_10_Handler
+                0x08001fd8                ADC_Handler
+                0x08001fd8                I2C1_EV_Handler
+                0x08001fd8                OTG_HS_WKUP_Handler
+                0x08001fd8                TAMP_STAMP_Handler
+                0x08001fd8                I2C3_ER_Handler
+                0x08001fd8                WWDG_Handler
+                0x08001fd8                DebugMonitor_Handler
+                0x08001fd8                EXTI4_Handler
+                0x08001fd8                I2C3_EV_Handler
+                0x08001fd8                DMA1_Stream4_Handler
+                0x08001fd8                DMA1_Stream1_Handler
+                0x08001fd8                DMA2_Stream4_Handler
+                0x08001fd8                DMA1_Stream7_Handler
+                0x08001fd8                OTG_FS_Handler
+                0x08001fd8                TIM1_BRK_TIM9_Handler
+                0x08001fd8                I2C1_ER_Handler
+                0x08001fd8                DMA1_Stream3_Handler
+                0x08001fd8                UsageFault_Handler
+                0x08001fd8                TIM1_UP_TIM10_Handler
+                0x08001fd8                CAN1_RX0_Handler
+                0x08001fd8                FMPI2C1_Handler
+                0x08001fd8                TIM1_CC_Handler
+                0x08001fd8                I2C2_ER_Handler
+                0x08001fd8                TIM8_CC_Handler
+                0x08001fd8                HDMI_CEC_Handler
+                0x08001fd8                SAI2_Handler
+                0x08001fd8                CAN1_SCE_Handler
+                0x08001fd8                FPU_Handler
+                0x08001fd8                DMA1_Stream0_Handler
+                0x08001fd8                OTG_HS_EP1_OUT_Handler
+                0x08001fd8                EXTI1_Handler
+                0x08001fd8                FMC_Handler
+                0x08001fd8                EXTI3_Handler
+                0x08001fd8                CAN1_TX_Handler
+                0x08001fd8                TIM8_TRG_COM_TIM14_Handler
+                0x08001fd8                EXTI2_Handler
+                0x08001fd8                UART4_Handler
+                0x08001fd8                CAN2_RX1_Handler
+                0x08001fd8                EXTI9_5_Handler
+                0x08001fd8                USART1_Handler
+                0x08001fd8                CAN2_SCE_Handler
+                0x08001fd8                TIM7_Handler
+                0x08001fd8                TIM3_Handler
+                0x08001fd8                DMA2_Stream6_Handler
+                0x08001fd8                Default_Handler
+                0x08001fd8                QuadSPI_Handler
+                0x08001fd8                DCMI_Handler
+                0x08001fd8                TIM5_Handler
+                0x08001fd8                TIM1_TRG_COM_TIM11_Handler
+                0x08001fd8                DMA1_Stream5_Handler
+                0x08001fd8                RTC_Alarm_Handler
+                0x08001fd8                TIM4_Handler
+                0x08001fd8                UART5_Handler
+                0x08001fd8                TIM8_UP_TIM13_Handler
+                0x08001fd8                CAN2_TX_Handler
+                0x08001fd8                SPI2_Handler
+                0x08001fd8                DMA2_Stream1_Handler
+                0x08001fd8                DMA1_Stream2_Handler
+                0x08001fd8                PVD_Handler
+                0x08001fd8                EXTI0_Handler
+                0x08001fd8                TIM8_BRK_TIM12_Handler
+                0x08001fd8                RCC_Handler
+                0x08001fd8                CAN2_RX0_Handler
+                0x08001fd8                DMA2_Stream5_Handler
+                0x08001fd8                DMA1_Stream6_Handler
+                0x08001fd8                SDIO_Handler
+                0x08001fd8                FMPI2C1_ERR_Handler
+                0x08001fd8                SPI1_Handler
+                0x08001fd8                DMA2_Stream0_Handler
+                0x08001fd8                I2C2_EV_Handler
+                0x08001fd8                SPDIF_Rx_Handler
+                0x08001fd8                SPI3_Handler
+                0x08001fd8                DMA2_Stream2_Handler
+                0x08001fde                create_tcb
+                0x0800209c                __set_user_mode
+                0x080020b0                PSP_Init
+                0x080020ca                sleep_state
+                0x080020d8                PendSV_Handler
+                0x08002200                yield
+                0x08002220                task_exit
+                0x0800228c                task0
+                0x080022c0                task1
+                0x080022f4                task2
+                0x08002328                task_for_fork
+                0x08002384                init_scheduler_for_fork
+                0x0800240c                start_task
+                0x0800242e                set_pending
+                0x08002452                getPID
+                0x08002478                fork
+                0x080024c8                init_tasks
+                0x0800262c                init_scheduler
+                0x08002798                find_file
+                0x080027e8                execve
+                0x08002820                file_A
+                0x08002880                file_B
+                0x080028a0                file_C
+                0x080028c0                init_file_system
+                0x08002974                init_task_for_execv
+                0x080029f4                kmain
+ .text          0x08002b64      0x104 object/stm32_startup.o
+                0x08002b6a                Reset_Handler
+                0x08002c30                HardFault_Handler
+                0x08002c36                MemManage_Handler
+                0x08002c3c                BusFault_Handler
+                0x08002c42                SVCall_Handler
+ .text          0x08002c68      0x308 object/sys_clock.o
+                0x08002c68                __init_sys_clock
+                0x08002d34                __APB1CLK_FREQ
+                0x08002db0                __APB2CLK_FREQ
+                0x08002e2c                __PLL_SYS_CLK
+                0x08002ec4                __AHB_CLK
+ .text          0x08002f70      0x584 object/sys_usart.o
+                0x08003020                UART_Init
+                0x080030ba                UART_DeInit
+                0x08003128                UART_BRR_SAMPLING16
+                0x080032bc                UART_MspInit
+ .text          0x080034f4      0x5c0 object/sys_gpio.o
+                0x080034f4                GPIO_WritePin
+                0x08003528                GPIO_Init
+                0x08003830                GPIO_DeInit
+                0x08003a18                SPI_GPIOInit
+ .text          0x08003ab4      0x324 object/kstdio.o
+                0x08003ab4                kprintf
+                0x08003c4c                kscanf
+ .text          0x08003dd8      0x148 object/sys_init.o
+                0x08003e20                __sys_init
+                0x08003e88                heap_init
+                0x08003f00                SYS_ROUTINE
+                0x08003f0c                display_group_info
+ .text          0x08003f20      0x3e0 object/unistd.o
+                0x08003f20                du_scanf
+                0x08003f4e                du_printf
+ .text          0x08004300       0xf0 object/times.o
+                0x08004300                du_getSystickTime
+                0x08004322                du_reboot
+                0x0800433a                du_malloc
+                0x08004366                du_free
+                0x0800439c                fopen
+                0x080043cc                fclose
+ .text          0x080043f0      0x7cc object/kunistd.o
+                0x080043f0                __sys_start_task
+                0x0800441a                __sys_fork
+                0x08004748                heap_malloc
+                0x0800494c                heap_free
+                0x080049ec                __sys_execv
+ .text          0x08004bbc      0x23c object/syscall.o
+                0x08004be4                syscall
+ .text          0x08004df8      0x1b8 object/serial_lin.o
+                0x08004df8                SerialLin2_init
+                0x08004e90                SerialLin6_init
+                0x08004f28                USART2_Handler
+                0x08004f3c                USART6_Handler
+                0x08004f50                noIntWrite
+                0x08004f80                noIntSendString
+ .text          0x08004fb0      0xd88 object/UsartRingBuffer.o
+                0x08004fb0                Ringbuf_init
+                0x0800504a                Look_for
+                0x080050ea                GetDataFromBuffer
+                0x0800522a                Uart_flush
+                0x08005266                Uart_peek
+                0x080052e0                Uart_read
+                0x08005380                Uart_write
+                0x08005438                IsDataAvailable
+                0x080054bc                Get_after
+                0x0800551a                Uart_sendstring
+                0x08005548                Uart_printbase
+                0x080055e0                Copy_upto
+                0x080056e0                Wait_for
+                0x080057ca                look_for_frame
+                0x08005930                Uart_isr
+                0x08005a3e                update_tail
+                0x08005aa4                debug_buffer
+                0x08005b2c                DRV_USART_INIT
+                0x08005be8                UART_SendChar
+                0x08005c16                _USART_WRITE
+                0x08005c44                _USART_READ
+                0x08005c96                UART_GetChar
+                0x08005cc0                _USART_READ_STR
+ .text          0x08005d38      0x110 object/debug.o
+                0x08005d38                __debugRamUsage
+                0x08005d84                __digitalWriteDebugButton
+                0x08005de0                __digitalReadDebugButton
+                0x08005e10                __alalogReadDebug
+                0x08005e28                __analogWriteDebug
+ .text          0x08005e48      0x228 object/timer.o
+                0x08005e84                ConfigTimer2ForSystem
+                0x08005f00                Delay_micro_second
+                0x08005f94                Delay
+                0x08005fc2                getMiliseconds
+                0x08006004                getMicroseconds
+                0x08006034                TIM2_Handler
+ .text          0x08006070       0x12 object/sys_err.o
+                0x08006070                Error_Handler
+ *fill*         0x08006082        0x2 
+ .text          0x08006084      0x364 object/sys_rtc.o
+                0x08006084                SYS_RTC_init
+                0x0800632c                get_timeofDay
+ .text          0x080063e8       0x14 object/app.o
+                0x080063e8                umain
+ *(.rodata)
+ .rodata        0x080063fc        0x8 object/cm4.o
+ .rodata        0x08006404       0x64 object/mcu_info.o
+ .rodata        0x08006468        0xa object/kstring.o
+ *fill*         0x08006472        0x2 
+ .rodata        0x08006474      0x24a object/kmain.o
+ *fill*         0x080066be        0x2 
+ .rodata        0x080066c0        0xc object/stm32_startup.o
+                0x080066c8                STACK_START
+ .rodata        0x080066cc       0x18 object/sys_clock.o
+                0x080066cc                AHBPrescTable
+                0x080066dc                APBPrescTable
+ .rodata        0x080066e4       0x80 object/sys_init.o
+ .rodata        0x08006764       0x1d object/times.o
+ *fill*         0x08006781        0x3 
+ .rodata        0x08006784      0x124 object/kunistd.o
+ .rodata        0x080068a8       0x72 object/syscall.o
+ *fill*         0x0800691a        0x2 
+ .rodata        0x0800691c        0xe object/app.o
+                0x0800692c                . = ALIGN (0x4)
+ *fill*         0x0800692a        0x2 
+                0x0800692c                _etext = .
+                0x0800692c                _la_data = LOADADDR (.data)
+
+.glue_7         0x0800692c        0x0
+ .glue_7        0x0800692c        0x0 linker stubs
+
+.glue_7t        0x0800692c        0x0
+ .glue_7t       0x0800692c        0x0 linker stubs
+
+.vfp11_veneer   0x0800692c        0x0
+ .vfp11_veneer  0x0800692c        0x0 linker stubs
+
+.v4_bx          0x0800692c        0x0
+ .v4_bx         0x0800692c        0x0 linker stubs
+
+.iplt           0x0800692c        0x0
+ .iplt          0x0800692c        0x0 object/kfloat.o
+
+.rel.dyn        0x0800692c        0x0
+ .rel.iplt      0x0800692c        0x0 object/kfloat.o
+
+.data           0x20000000       0x78 load address 0x0800692c
+                0x20000000                _sdata = .
+ *(.data)
+ .data          0x20000000        0x0 object/kmath.o
+ .data          0x20000000        0x0 object/kfloat.o
+ .data          0x20000000        0x0 object/cm4.o
+ .data          0x20000000        0x0 object/mcu_info.o
+ .data          0x20000000       0x61 object/kstring.o
+ *fill*         0x20000061        0x3 
+ .data          0x20000064        0xc object/kmain.o
+                0x20000064                QUEUE_SIZE_P
+                0x20000068                TASK_ID
+                0x2000006c                size
+ .data          0x20000070        0x0 object/stm32_startup.o
+ .data          0x20000070        0x0 object/sys_clock.o
+ .data          0x20000070        0x0 object/sys_usart.o
+ .data          0x20000070        0x0 object/sys_gpio.o
+ .data          0x20000070        0x0 object/kstdio.o
+ .data          0x20000070        0x0 object/sys_init.o
+ .data          0x20000070        0x0 object/unistd.o
+ .data          0x20000070        0x0 object/times.o
+ .data          0x20000070        0x0 object/kunistd.o
+ .data          0x20000070        0x0 object/syscall.o
+ .data          0x20000070        0x8 object/serial_lin.o
+                0x20000070                errObj
+ .data          0x20000078        0x0 object/UsartRingBuffer.o
+ .data          0x20000078        0x0 object/debug.o
+ .data          0x20000078        0x0 object/timer.o
+ .data          0x20000078        0x0 object/sys_err.o
+ .data          0x20000078        0x0 object/sys_rtc.o
+ .data          0x20000078        0x0 object/app.o
+                0x20000078                . = ALIGN (0x4)
+                0x20000078                _edata = .
+
+.igot.plt       0x20000078        0x0 load address 0x080069a4
+ .igot.plt      0x20000078        0x0 object/kfloat.o
+
+.bss            0x20000078     0x14b1 load address 0x080069a4
+                0x20000078                _sbss = .
+ *(.bss)
+ .bss           0x20000078        0x0 object/kmath.o
+ .bss           0x20000078        0x0 object/kfloat.o
+ .bss           0x20000078       0x11 object/cm4.o
+                0x20000088                __PendSV_Flag
+ *fill*         0x20000089        0x3 
+ .bss           0x2000008c       0x14 object/mcu_info.o
+ .bss           0x200000a0       0x32 object/kstring.o
+ *fill*         0x200000d2        0x2 
+ .bss           0x200000d4      0xba0 object/kmain.o
+                0x200000d4                CURR_TASK_P
+                0x200000d8                READY_QUEUE
+                0x20000164                psp_stack_addresses
+                0x2000016c                CURR_TASK
+                0x20000170                file_list
+                0x20000c70                file_count
+ .bss           0x20000c74        0x0 object/stm32_startup.o
+ .bss           0x20000c74        0x0 object/sys_clock.o
+ .bss           0x20000c74        0x0 object/sys_usart.o
+ .bss           0x20000c74        0x0 object/sys_gpio.o
+ .bss           0x20000c74        0x0 object/kstdio.o
+ .bss           0x20000c74       0x14 object/sys_init.o
+                0x20000c74                heap
+ .bss           0x20000c88        0x0 object/unistd.o
+ .bss           0x20000c88        0x0 object/times.o
+ .bss           0x20000c88        0x0 object/kunistd.o
+ .bss           0x20000c88        0x0 object/syscall.o
+ .bss           0x20000c88      0x890 object/serial_lin.o
+                0x20000c88                huart2
+                0x200010d0                huart6
+ .bss           0x20001518        0x0 object/UsartRingBuffer.o
+ .bss           0x20001518        0xc object/debug.o
+                0x2000151c                CURRENT_MSP
+                0x20001520                DEBUG_BUTTON
+                0x20001522                DEBUG_ANALOG_IO
+ .bss           0x20001524        0x5 object/timer.o
+ .bss           0x20001529        0x0 object/sys_err.o
+ .bss           0x20001529        0x0 object/sys_rtc.o
+ .bss           0x20001529        0x0 object/app.o
+                0x20001529                _ebss = .
+
+.heap           0x20001529     0x8003 load address 0x080069a4
+                0x2000152c                . = ALIGN (0x4)
+ *fill*         0x20001529        0x3 
+                0x2000152c                _sheap = .
+                0x2000952c                . = (. + 0x8000)
+ *fill*         0x2000152c     0x8000 
+ *(.heap)
+                0x2000952c                . = ALIGN (0x4)
+                0x2000952c                _eheap = .
+OUTPUT(build/final.elf elf32-littlearm)
+LOAD linker stubs
+
+.debug_info     0x00000000     0x8c22
+ .debug_info    0x00000000       0xdf object/kmath.o
+ .debug_info    0x000000df      0x824 object/kfloat.o
+ .debug_info    0x00000903      0x8f6 object/cm4.o
+ .debug_info    0x000011f9      0x230 object/mcu_info.o
+ .debug_info    0x00001429      0x811 object/kstring.o
+ .debug_info    0x00001c3a      0xefa object/kmain.o
+ .debug_info    0x00002b34      0x2a1 object/stm32_startup.o
+ .debug_info    0x00002dd5      0x4d3 object/sys_clock.o
+ .debug_info    0x000032a8      0xd57 object/sys_usart.o
+ .debug_info    0x00003fff      0x904 object/sys_gpio.o
+ .debug_info    0x00004903      0x240 object/kstdio.o
+ .debug_info    0x00004b43      0x677 object/sys_init.o
+ .debug_info    0x000051ba      0x28d object/unistd.o
+ .debug_info    0x00005447      0x1d3 object/times.o
+ .debug_info    0x0000561a      0x7c7 object/kunistd.o
+ .debug_info    0x00005de1      0x818 object/syscall.o
+ .debug_info    0x000065f9      0x52a object/serial_lin.o
+ .debug_info    0x00006b23      0xeec object/UsartRingBuffer.o
+ .debug_info    0x00007a0f      0x1ee object/debug.o
+ .debug_info    0x00007bfd      0x8c1 object/timer.o
+ .debug_info    0x000084be       0xea object/sys_err.o
+ .debug_info    0x000085a8      0x5f4 object/sys_rtc.o
+ .debug_info    0x00008b9c       0x86 object/app.o
+
+.debug_abbrev   0x00000000     0x23f2
+ .debug_abbrev  0x00000000       0x83 object/kmath.o
+ .debug_abbrev  0x00000083      0x141 object/kfloat.o
+ .debug_abbrev  0x000001c4      0x263 object/cm4.o
+ .debug_abbrev  0x00000427      0x11b object/mcu_info.o
+ .debug_abbrev  0x00000542      0x1dc object/kstring.o
+ .debug_abbrev  0x0000071e      0x396 object/kmain.o
+ .debug_abbrev  0x00000ab4       0xf7 object/stm32_startup.o
+ .debug_abbrev  0x00000bab      0x109 object/sys_clock.o
+ .debug_abbrev  0x00000cb4      0x25c object/sys_usart.o
+ .debug_abbrev  0x00000f10      0x175 object/sys_gpio.o
+ .debug_abbrev  0x00001085      0x117 object/kstdio.o
+ .debug_abbrev  0x0000119c      0x1f5 object/sys_init.o
+ .debug_abbrev  0x00001391      0x103 object/unistd.o
+ .debug_abbrev  0x00001494      0x134 object/times.o
+ .debug_abbrev  0x000015c8      0x1ec object/kunistd.o
+ .debug_abbrev  0x000017b4      0x1fc object/syscall.o
+ .debug_abbrev  0x000019b0      0x1f7 object/serial_lin.o
+ .debug_abbrev  0x00001ba7      0x32d object/UsartRingBuffer.o
+ .debug_abbrev  0x00001ed4      0x12f object/debug.o
+ .debug_abbrev  0x00002003      0x1fe object/timer.o
+ .debug_abbrev  0x00002201       0x9b object/sys_err.o
+ .debug_abbrev  0x0000229c      0x10f object/sys_rtc.o
+ .debug_abbrev  0x000023ab       0x47 object/app.o
+
+.debug_aranges  0x00000000      0x2e0
+ .debug_aranges
+                0x00000000       0x20 object/kmath.o
+ .debug_aranges
+                0x00000020       0x20 object/kfloat.o
+ .debug_aranges
+                0x00000040       0x20 object/cm4.o
+ .debug_aranges
+                0x00000060       0x20 object/mcu_info.o
+ .debug_aranges
+                0x00000080       0x20 object/kstring.o
+ .debug_aranges
+                0x000000a0       0x20 object/kmain.o
+ .debug_aranges
+                0x000000c0       0x20 object/stm32_startup.o
+ .debug_aranges
+                0x000000e0       0x20 object/sys_clock.o
+ .debug_aranges
+                0x00000100       0x20 object/sys_usart.o
+ .debug_aranges
+                0x00000120       0x20 object/sys_gpio.o
+ .debug_aranges
+                0x00000140       0x20 object/kstdio.o
+ .debug_aranges
+                0x00000160       0x20 object/sys_init.o
+ .debug_aranges
+                0x00000180       0x20 object/unistd.o
+ .debug_aranges
+                0x000001a0       0x20 object/times.o
+ .debug_aranges
+                0x000001c0       0x20 object/kunistd.o
+ .debug_aranges
+                0x000001e0       0x20 object/syscall.o
+ .debug_aranges
+                0x00000200       0x20 object/serial_lin.o
+ .debug_aranges
+                0x00000220       0x20 object/UsartRingBuffer.o
+ .debug_aranges
+                0x00000240       0x20 object/debug.o
+ .debug_aranges
+                0x00000260       0x20 object/timer.o
+ .debug_aranges
+                0x00000280       0x20 object/sys_err.o
+ .debug_aranges
+                0x000002a0       0x20 object/sys_rtc.o
+ .debug_aranges
+                0x000002c0       0x20 object/app.o
+
+.debug_macro    0x00000000    0x1e805
+ .debug_macro   0x00000000       0x6d object/kmath.o
+ .debug_macro   0x0000006d      0xa66 object/kmath.o
+ .debug_macro   0x00000ad3       0x22 object/kmath.o
+ .debug_macro   0x00000af5       0x8e object/kmath.o
+ .debug_macro   0x00000b83       0x51 object/kmath.o
+ .debug_macro   0x00000bd4      0x103 object/kmath.o
+ .debug_macro   0x00000cd7       0x6a object/kmath.o
+ .debug_macro   0x00000d41      0x1df object/kmath.o
+ .debug_macro   0x00000f20       0x85 object/kfloat.o
+ .debug_macro   0x00000fa5       0x1c object/kfloat.o
+ .debug_macro   0x00000fc1       0x8c object/kfloat.o
+ .debug_macro   0x0000104d       0xfc object/cm4.o
+ .debug_macro   0x00001149       0x66 object/cm4.o
+ .debug_macro   0x000011af      0x75c object/cm4.o
+ .debug_macro   0x0000190b     0xd558 object/cm4.o
+ .debug_macro   0x0000ee63       0x16 object/cm4.o
+ .debug_macro   0x0000ee79      0x244 object/cm4.o
+ .debug_macro   0x0000f0bd       0x1c object/cm4.o
+ .debug_macro   0x0000f0d9       0x9a object/cm4.o
+ .debug_macro   0x0000f173       0x10 object/cm4.o
+ .debug_macro   0x0000f183       0x58 object/cm4.o
+ .debug_macro   0x0000f1db      0x1a1 object/cm4.o
+ .debug_macro   0x0000f37c       0x99 object/mcu_info.o
+ .debug_macro   0x0000f415     0xd552 object/mcu_info.o
+ .debug_macro   0x0001c967       0x93 object/kstring.o
+ .debug_macro   0x0001c9fa       0x22 object/kstring.o
+ .debug_macro   0x0001ca1c      0x131 object/kmain.o
+ .debug_macro   0x0001cb4d      0x19b object/kmain.o
+ .debug_macro   0x0001cce8       0x3a object/kmain.o
+ .debug_macro   0x0001cd22       0x10 object/kmain.o
+ .debug_macro   0x0001cd32       0xf1 object/stm32_startup.o
+ .debug_macro   0x0001ce23       0x6c object/stm32_startup.o
+ .debug_macro   0x0001ce8f       0x81 object/sys_clock.o
+ .debug_macro   0x0001cf10       0xd9 object/sys_usart.o
+ .debug_macro   0x0001cfe9       0xdd object/sys_usart.o
+ .debug_macro   0x0001d0c6      0x140 object/sys_usart.o
+ .debug_macro   0x0001d206       0x1c object/sys_usart.o
+ .debug_macro   0x0001d222       0x10 object/sys_usart.o
+ .debug_macro   0x0001d232      0x762 object/sys_usart.o
+ .debug_macro   0x0001d994      0x201 object/sys_usart.o
+ .debug_macro   0x0001db95       0xb5 object/sys_gpio.o
+ .debug_macro   0x0001dc4a       0xbc object/kstdio.o
+ .debug_macro   0x0001dd06       0x10 object/kstdio.o
+ .debug_macro   0x0001dd16      0x124 object/sys_init.o
+ .debug_macro   0x0001de3a       0xe3 object/sys_init.o
+ .debug_macro   0x0001df1d       0x16 object/sys_init.o
+ .debug_macro   0x0001df33       0x2e object/sys_init.o
+ .debug_macro   0x0001df61       0xaa object/unistd.o
+ .debug_macro   0x0001e00b       0x7f object/times.o
+ .debug_macro   0x0001e08a       0x9f object/kunistd.o
+ .debug_macro   0x0001e129       0xed object/syscall.o
+ .debug_macro   0x0001e216       0xba object/serial_lin.o
+ .debug_macro   0x0001e2d0       0xd2 object/UsartRingBuffer.o
+ .debug_macro   0x0001e3a2       0x58 object/UsartRingBuffer.o
+ .debug_macro   0x0001e3fa       0x7b object/debug.o
+ .debug_macro   0x0001e475       0x10 object/debug.o
+ .debug_macro   0x0001e485       0xd3 object/timer.o
+ .debug_macro   0x0001e558       0x28 object/timer.o
+ .debug_macro   0x0001e580       0x8f object/sys_err.o
+ .debug_macro   0x0001e60f       0x86 object/sys_err.o
+ .debug_macro   0x0001e695       0x84 object/sys_rtc.o
+ .debug_macro   0x0001e719       0x34 object/sys_rtc.o
+ .debug_macro   0x0001e74d       0xb8 object/app.o
+
+.debug_line     0x00000000     0x66f4
+ .debug_line    0x00000000      0x20c object/kmath.o
+ .debug_line    0x0000020c      0x6cd object/kfloat.o
+ .debug_line    0x000008d9      0x45e object/cm4.o
+ .debug_line    0x00000d37      0x348 object/mcu_info.o
+ .debug_line    0x0000107f      0x7ca object/kstring.o
+ .debug_line    0x00001849      0x853 object/kmain.o
+ .debug_line    0x0000209c      0x3ee object/stm32_startup.o
+ .debug_line    0x0000248a      0x39b object/sys_clock.o
+ .debug_line    0x00002825      0x4db object/sys_usart.o
+ .debug_line    0x00002d00      0x61b object/sys_gpio.o
+ .debug_line    0x0000331b      0x3be object/kstdio.o
+ .debug_line    0x000036d9      0x3c5 object/sys_init.o
+ .debug_line    0x00003a9e      0x407 object/unistd.o
+ .debug_line    0x00003ea5      0x251 object/times.o
+ .debug_line    0x000040f6      0x586 object/kunistd.o
+ .debug_line    0x0000467c      0x3da object/syscall.o
+ .debug_line    0x00004a56      0x34e object/serial_lin.o
+ .debug_line    0x00004da4      0xac7 object/UsartRingBuffer.o
+ .debug_line    0x0000586b      0x265 object/debug.o
+ .debug_line    0x00005ad0      0x3c1 object/timer.o
+ .debug_line    0x00005e91      0x25c object/sys_err.o
+ .debug_line    0x000060ed      0x361 object/sys_rtc.o
+ .debug_line    0x0000644e      0x2a6 object/app.o
+
+.debug_str      0x00000000    0x53194
+ .debug_str     0x00000000     0x3a65 object/kmath.o
+                               0x3bc9 (size before relaxing)
+ .debug_str     0x00003a65      0x427 object/kfloat.o
+                               0x3ffb (size before relaxing)
+ .debug_str     0x00003e8c    0x4bbfa object/cm4.o
+                              0x4fa1a (size before relaxing)
+ .debug_str     0x0004fa86       0xc6 object/mcu_info.o
+                              0x4a831 (size before relaxing)
+ .debug_str     0x0004fb4c      0x14b object/kstring.o
+                               0x3ffc (size before relaxing)
+ .debug_str     0x0004fc97      0x3f5 object/kmain.o
+                              0x4fcb7 (size before relaxing)
+ .debug_str     0x0005008c      0x10f object/stm32_startup.o
+                              0x4f338 (size before relaxing)
+ .debug_str     0x0005019b      0x271 object/sys_clock.o
+                              0x4a81c (size before relaxing)
+ .debug_str     0x0005040c     0x1eee object/sys_usart.o
+                              0x5104a (size before relaxing)
+ .debug_str     0x000522fa      0x278 object/sys_gpio.o
+                              0x4c1e5 (size before relaxing)
+ .debug_str     0x00052572       0x66 object/kstdio.o
+                              0x4bf9b (size before relaxing)
+ .debug_str     0x000525d8      0x1eb object/sys_init.o
+                              0x504da (size before relaxing)
+ .debug_str     0x000527c3       0x50 object/unistd.o
+                               0x7664 (size before relaxing)
+ .debug_str     0x00052813       0x71 object/times.o
+                               0x435b (size before relaxing)
+ .debug_str     0x00052884       0x95 object/kunistd.o
+                               0x744c (size before relaxing)
+ .debug_str     0x00052919       0x78 object/syscall.o
+                              0x4f5cf (size before relaxing)
+ .debug_str     0x00052991      0x10f object/serial_lin.o
+                              0x4bae5 (size before relaxing)
+ .debug_str     0x00052aa0      0x336 object/UsartRingBuffer.o
+                              0x4f083 (size before relaxing)
+ .debug_str     0x00052dd6       0xc2 object/debug.o
+                               0x3dd4 (size before relaxing)
+ .debug_str     0x00052e98      0x115 object/timer.o
+                              0x4f7c2 (size before relaxing)
+ .debug_str     0x00052fad       0x3f object/sys_err.o
+                              0x4a7ba (size before relaxing)
+ .debug_str     0x00052fec      0x18a object/sys_rtc.o
+                              0x4a990 (size before relaxing)
+ .debug_str     0x00053176       0x1e object/app.o
+                               0x75d7 (size before relaxing)
+
+.comment        0x00000000       0x4d
+ .comment       0x00000000       0x4d object/kmath.o
+                                 0x4e (size before relaxing)
+ .comment       0x0000004d       0x4e object/kfloat.o
+ .comment       0x0000004d       0x4e object/cm4.o
+ .comment       0x0000004d       0x4e object/mcu_info.o
+ .comment       0x0000004d       0x4e object/kstring.o
+ .comment       0x0000004d       0x4e object/kmain.o
+ .comment       0x0000004d       0x4e object/stm32_startup.o
+ .comment       0x0000004d       0x4e object/sys_clock.o
+ .comment       0x0000004d       0x4e object/sys_usart.o
+ .comment       0x0000004d       0x4e object/sys_gpio.o
+ .comment       0x0000004d       0x4e object/kstdio.o
+ .comment       0x0000004d       0x4e object/sys_init.o
+ .comment       0x0000004d       0x4e object/unistd.o
+ .comment       0x0000004d       0x4e object/times.o
+ .comment       0x0000004d       0x4e object/kunistd.o
+ .comment       0x0000004d       0x4e object/syscall.o
+ .comment       0x0000004d       0x4e object/serial_lin.o
+ .comment       0x0000004d       0x4e object/UsartRingBuffer.o
+ .comment       0x0000004d       0x4e object/debug.o
+ .comment       0x0000004d       0x4e object/timer.o
+ .comment       0x0000004d       0x4e object/sys_err.o
+ .comment       0x0000004d       0x4e object/sys_rtc.o
+ .comment       0x0000004d       0x4e object/app.o
+
+.ARM.attributes
+                0x00000000       0x32
+ .ARM.attributes
+                0x00000000       0x32 object/kmath.o
+ .ARM.attributes
+                0x00000032       0x32 object/kfloat.o
+ .ARM.attributes
+                0x00000064       0x32 object/cm4.o
+ .ARM.attributes
+                0x00000096       0x32 object/mcu_info.o
+ .ARM.attributes
+                0x000000c8       0x32 object/kstring.o
+ .ARM.attributes
+                0x000000fa       0x32 object/kmain.o
+ .ARM.attributes
+                0x0000012c       0x32 object/stm32_startup.o
+ .ARM.attributes
+                0x0000015e       0x32 object/sys_clock.o
+ .ARM.attributes
+                0x00000190       0x32 object/sys_usart.o
+ .ARM.attributes
+                0x000001c2       0x32 object/sys_gpio.o
+ .ARM.attributes
+                0x000001f4       0x32 object/kstdio.o
+ .ARM.attributes
+                0x00000226       0x32 object/sys_init.o
+ .ARM.attributes
+                0x00000258       0x32 object/unistd.o
+ .ARM.attributes
+                0x0000028a       0x32 object/times.o
+ .ARM.attributes
+                0x000002bc       0x32 object/kunistd.o
+ .ARM.attributes
+                0x000002ee       0x32 object/syscall.o
+ .ARM.attributes
+                0x00000320       0x32 object/serial_lin.o
+ .ARM.attributes
+                0x00000352       0x32 object/UsartRingBuffer.o
+ .ARM.attributes
+                0x00000384       0x32 object/debug.o
+ .ARM.attributes
+                0x000003b6       0x32 object/timer.o
+ .ARM.attributes
+                0x000003e8       0x32 object/sys_err.o
+ .ARM.attributes
+                0x0000041a       0x32 object/sys_rtc.o
+ .ARM.attributes
+                0x0000044c       0x32 object/app.o
+
+.debug_frame    0x00000000     0x1ba4
+ .debug_frame   0x00000000       0x38 object/kmath.o
+ .debug_frame   0x00000038      0x2b4 object/kfloat.o
+ .debug_frame   0x000002ec      0x2b8 object/cm4.o
+ .debug_frame   0x000005a4       0x7c object/mcu_info.o
+ .debug_frame   0x00000620      0x340 object/kstring.o
+ .debug_frame   0x00000960      0x3e8 object/kmain.o
+ .debug_frame   0x00000d48       0xb8 object/stm32_startup.o
+ .debug_frame   0x00000e00       0xc4 object/sys_clock.o
+ .debug_frame   0x00000ec4      0x144 object/sys_usart.o
+ .debug_frame   0x00001008       0xb0 object/sys_gpio.o
+ .debug_frame   0x000010b8       0x8c object/kstdio.o
+ .debug_frame   0x00001144       0xa8 object/sys_init.o
+ .debug_frame   0x000011ec       0x88 object/unistd.o
+ .debug_frame   0x00001274       0xf4 object/times.o
+ .debug_frame   0x00001368       0xdc object/kunistd.o
+ .debug_frame   0x00001444       0x4c object/syscall.o
+ .debug_frame   0x00001490       0xdc object/serial_lin.o
+ .debug_frame   0x0000156c      0x3a4 object/UsartRingBuffer.o
+ .debug_frame   0x00001910       0xcc object/debug.o
+ .debug_frame   0x000019dc      0x10c object/timer.o
+ .debug_frame   0x00001ae8       0x2c object/sys_err.o
+ .debug_frame   0x00001b14       0x64 object/sys_rtc.o
+ .debug_frame   0x00001b78       0x2c object/app.o
+
+.debug_ranges   0x00000000       0x18
+ .debug_ranges  0x00000000       0x18 object/UsartRingBuffer.o
Binary files duos24/src/compile/object/UsartRingBuffer.o and duos24_1/src/compile/object/UsartRingBuffer.o differ
Binary files duos24/src/compile/object/app.o and duos24_1/src/compile/object/app.o differ
Binary files duos24/src/compile/object/cm4.o and duos24_1/src/compile/object/cm4.o differ
Binary files duos24/src/compile/object/debug.o and duos24_1/src/compile/object/debug.o differ
Binary files duos24/src/compile/object/kfloat.o and duos24_1/src/compile/object/kfloat.o differ
Binary files duos24/src/compile/object/kmain.o and duos24_1/src/compile/object/kmain.o differ
Binary files duos24/src/compile/object/kmath.o and duos24_1/src/compile/object/kmath.o differ
Binary files duos24/src/compile/object/kstdio.o and duos24_1/src/compile/object/kstdio.o differ
Binary files duos24/src/compile/object/kstring.o and duos24_1/src/compile/object/kstring.o differ
Binary files duos24/src/compile/object/ktimes.o and duos24_1/src/compile/object/ktimes.o differ
Binary files duos24/src/compile/object/kunistd.o and duos24_1/src/compile/object/kunistd.o differ
Binary files duos24/src/compile/object/mcu_info.o and duos24_1/src/compile/object/mcu_info.o differ
Binary files duos24/src/compile/object/serial_lin.o and duos24_1/src/compile/object/serial_lin.o differ
Binary files duos24/src/compile/object/stm32_startup.o and duos24_1/src/compile/object/stm32_startup.o differ
Binary files duos24/src/compile/object/sys_clock.o and duos24_1/src/compile/object/sys_clock.o differ
Binary files duos24/src/compile/object/sys_err.o and duos24_1/src/compile/object/sys_err.o differ
Binary files duos24/src/compile/object/sys_gpio.o and duos24_1/src/compile/object/sys_gpio.o differ
Binary files duos24/src/compile/object/sys_init.o and duos24_1/src/compile/object/sys_init.o differ
Binary files duos24/src/compile/object/sys_rtc.o and duos24_1/src/compile/object/sys_rtc.o differ
Binary files duos24/src/compile/object/sys_spi.o and duos24_1/src/compile/object/sys_spi.o differ
Binary files duos24/src/compile/object/sys_timer.o and duos24_1/src/compile/object/sys_timer.o differ
Binary files duos24/src/compile/object/sys_usart.o and duos24_1/src/compile/object/sys_usart.o differ
Binary files duos24/src/compile/object/syscall.o and duos24_1/src/compile/object/syscall.o differ
Binary files duos24/src/compile/object/timer.o and duos24_1/src/compile/object/timer.o differ
Binary files duos24/src/compile/object/times.o and duos24_1/src/compile/object/times.o differ
Binary files duos24/src/compile/object/unistd.o and duos24_1/src/compile/object/unistd.o differ
Binary files duos24/src/compile/target/duos and duos24_1/src/compile/target/duos differ
diff -ruN duos24/src/kern/arch/cm4/cm4.c duos24_1/src/kern/arch/cm4/cm4.c
--- duos24/src/kern/arch/cm4/cm4.c	2025-03-20 15:35:29.484808700 +0600
+++ duos24_1/src/kern/arch/cm4/cm4.c	2025-03-16 18:28:21.226744500 +0600
@@ -30,12 +30,13 @@
  
 #include <cm4.h>
 #include <sys_clock.h>
-#include <syscall.h>
+#include <sys_call.h>
 
 static volatile uint32_t __mscount;
 static volatile uint32_t __sec_count;
 static volatile uint32_t __min_count;
 static volatile uint32_t __hour_count;
+extern volatile uint8_t __PendSV_Flag = 0;
 /************************************************************************************
 * __SysTick_init(uint32_t reload) 
 * Function initialize the SysTick clock. The function with a weak attribute enables 
@@ -122,6 +123,8 @@
 void SysTick_Handler(void)
 {
     __mscount+=(SYSTICK->LOAD)/(PLL_N*1000);
+
+    if(__PendSV_Flag) SCB->ICSR |= (1 << 28); // set PendSV bit
 }
 
 void __enable_fpu()
@@ -155,4 +158,8 @@
 void SYS_SLEEP_WFI(void)
 {
     __WFI();
+}
+
+void __set_pending(uint8_t flag){
+    __PendSV_Flag = flag;
 }
\ No newline at end of file
diff -ruN duos24/src/kern/arch/include/cm4/cm4.h duos24_1/src/kern/arch/include/cm4/cm4.h
--- duos24/src/kern/arch/include/cm4/cm4.h	2025-03-20 15:35:29.506955600 +0600
+++ duos24_1/src/kern/arch/include/cm4/cm4.h	2025-03-16 18:28:21.242520800 +0600
@@ -676,22 +676,25 @@
 /**
 * Function related to SysTick
 */
-void __SysTick_init(uint32_t);
-void __SysTick_enable(void);
-void __SysTick_disable(void);
-uint32_t __getSysTickCount(void);
-void __updateSysTick(uint32_t) ;
-uint32_t __getTime(void);
-uint32_t __get__Second(void);
-uint32_t __get__Minute(void);
-uint32_t __get__Hour(void);
-uint32_t getmsTick(void);
-void SysTick_Handler(void);
-uint8_t ms_delay(uint32_t);
-uint32_t wait_until(uint32_t);
-void SysTickIntDisable(void);
-void SysTickIntEnable(void);
-void SYS_SLEEP_WFI(void);
+__attribute__((weak)) void __SysTick_init(uint32_t);
+__attribute__((weak)) void __SysTick_enable(void);
+__attribute__((weak)) void __SysTick_disable(void);
+__attribute__((weak)) uint32_t __getSysTickCount(void);
+__attribute__((weak)) void __updateSysTick(uint32_t) ;
+__attribute__((weak)) uint32_t __getTime(void);
+__attribute__((weak)) uint32_t __get__Second(void);
+__attribute__((weak)) uint32_t __get__Minute(void);
+__attribute__((weak)) uint32_t __get__Hour(void);
+__attribute__((weak)) uint32_t getmsTick(void);
+__attribute__((weak)) uint8_t ms_delay(uint32_t);
+__attribute__((weak)) uint32_t wait_until(uint32_t);
+__attribute__((weak)) void SysTickIntDisable(void);
+__attribute__((weak)) void SysTickIntEnable(void);
+__attribute__((weak)) void SYS_SLEEP_WFI(void);
+
+
+
+void __set_pending(uint8_t value);
 /**
 * Functions on FPU
 **/
diff -ruN duos24/src/kern/arch/stm32f446re/include/stm32_startup.h duos24_1/src/kern/arch/stm32f446re/include/stm32_startup.h
--- duos24/src/kern/arch/stm32f446re/include/stm32_startup.h	2025-03-20 15:35:29.770011300 +0600
+++ duos24_1/src/kern/arch/stm32f446re/include/stm32_startup.h	2025-03-16 18:28:21.464766600 +0600
@@ -36,10 +36,11 @@
 
 #include <stdint.h>
 #include <sys_bus_matrix.h>
+#include <sys_call.h>
 
 
 
-int kmain(void);
+void kmain(void);
 
 extern uint32_t _stext;
 extern uint32_t _etext;
@@ -49,9 +50,17 @@
 extern uint32_t _ebss;
 extern uint32_t _la_data;
 
-volatile uint32_t _bss_size=0;
-volatile uint32_t _data_size=0;
-volatile uint32_t _text_size=0;
+extern uint32_t _sheap;
+extern uint32_t _eheap;
+
+extern volatile uint32_t _bss_size;
+extern volatile uint32_t _data_size;
+extern volatile uint32_t _text_size;
+extern volatile uint32_t _heap_size;
+
+__attribute__((weak)) void Default_Handler(void){
+    while(1);
+}
 
 void Reset_Handler(void) __attribute__((weak));
 void NMI_Handler(void) __attribute__((weak, alias("Default_Handler")));
@@ -61,7 +70,7 @@
 void UsageFault_Handler(void) __attribute__((weak, alias("Default_Handler")));
 void SVCall_Handler(void) __attribute__((weak));
 void DebugMonitor_Handler(void) __attribute__((weak, alias("Default_Handler")));
-void PendSV_Handler(void) __attribute__((weak, alias("Default_Handler")));
+void PendSV_Handler(void) __attribute__((naked));
 void SysTick_Handler(void) __attribute__((weak));
 void WWDG_Handler(void) __attribute__((weak, alias("Default_Handler")));
 void PVD_Handler(void) __attribute__((weak, alias("Default_Handler")));
@@ -151,6 +160,7 @@
 void FMPI2C1_ERR_Handler(void) __attribute__((weak, alias("Default_Handler")));
 
 
+
 void update_global_tick_count(void);
 
 
diff -ruN duos24/src/kern/arch/stm32f446re/linker/linker.ld duos24_1/src/kern/arch/stm32f446re/linker/linker.ld
--- duos24/src/kern/arch/stm32f446re/linker/linker.ld	2025-03-20 15:35:29.712008300 +0600
+++ duos24_1/src/kern/arch/stm32f446re/linker/linker.ld	2025-03-16 18:28:21.417416900 +0600
@@ -33,4 +33,13 @@
 		*(.bss)
 		_ebss = .; 
 	}>SRAM
+
+	.heap :
+	{	. = ALIGN(4);
+		_sheap = .;
+		. = . + 32K;
+		*(.heap)
+		. = ALIGN(4);
+		_eheap = .;
+	}>SRAM
 }
diff -ruN duos24/src/kern/arch/stm32f446re/sys_lib/stm32_startup.c duos24_1/src/kern/arch/stm32f446re/sys_lib/stm32_startup.c
--- duos24/src/kern/arch/stm32f446re/sys_lib/stm32_startup.c	2025-03-20 15:35:29.627829200 +0600
+++ duos24_1/src/kern/arch/stm32f446re/sys_lib/stm32_startup.c	2025-03-16 18:28:21.369955800 +0600
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 
+ * Copyright (c) 2022
  * Computer Science and Engineering, University of Dhaka
  * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
  *
@@ -27,170 +27,191 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
- 
+
 #include <stm32_startup.h>
+
 const uint32_t STACK_START = (uint32_t)SRAM_END;
-uint32_t NVIC_VECTOR[] __attribute__((section (".isr_vector")))={
+uint32_t NVIC_VECTOR[] __attribute__((section(".isr_vector"))) = {
 	STACK_START,
-	(uint32_t) &Reset_Handler,
-	(uint32_t) &NMI_Handler,
-	(uint32_t) &HardFault_Handler,
-	(uint32_t) &MemManage_Handler,
-	(uint32_t) &BusFault_Handler,
-	(uint32_t) &UsageFault_Handler,
-	0,
-	0,
-	0,
-	0,
-	(uint32_t) &SVCall_Handler,
-	(uint32_t) &DebugMonitor_Handler,
-	0,
-	(uint32_t) &PendSV_Handler,
-	(uint32_t) &SysTick_Handler,
-	(uint32_t) &WWDG_Handler,
-	(uint32_t) &PVD_Handler,
-	(uint32_t) &TAMP_STAMP_Handler,
-	(uint32_t) &RTC_WKUP_Handler,
-	(uint32_t) &FLASH_Handler,
-	(uint32_t) &RCC_Handler,
-	(uint32_t) &EXTI0_Handler,
-	(uint32_t) &EXTI1_Handler,
-	(uint32_t) &EXTI2_Handler,
-	(uint32_t) &EXTI3_Handler,
-	(uint32_t) &EXTI4_Handler,
-	(uint32_t) &DMA1_Stream0_Handler,
-	(uint32_t) &DMA1_Stream1_Handler,
-	(uint32_t) &DMA1_Stream2_Handler,
-	(uint32_t) &DMA1_Stream3_Handler,
-	(uint32_t) &DMA1_Stream4_Handler,
-	(uint32_t) &DMA1_Stream5_Handler,
-	(uint32_t) &DMA1_Stream6_Handler,
-	(uint32_t) &ADC_Handler,
-	(uint32_t) &CAN1_TX_Handler,
-	(uint32_t) &CAN1_RX0_Handler,
-	(uint32_t) &CAN1_RX1_Handler,
-	(uint32_t) &CAN1_SCE_Handler,
-	(uint32_t) &EXTI9_5_Handler,
-	(uint32_t) &TIM1_BRK_TIM9_Handler,
-	(uint32_t) &TIM1_UP_TIM10_Handler,
-	(uint32_t) &TIM1_TRG_COM_TIM11_Handler,
-	(uint32_t) &TIM1_CC_Handler,
-	(uint32_t) &TIM2_Handler,
-	(uint32_t) &TIM3_Handler,
-	(uint32_t) &TIM4_Handler,
-	(uint32_t) &I2C1_EV_Handler,
-	(uint32_t) &I2C1_ER_Handler,
-	(uint32_t) &I2C2_EV_Handler,
-	(uint32_t) &I2C2_ER_Handler,
-	(uint32_t) &SPI1_Handler,
-	(uint32_t) &SPI2_Handler,
-	(uint32_t) &USART1_Handler,
-	(uint32_t) &USART2_Handler,
-	(uint32_t) &USART3_Handler,
-	(uint32_t) &EXTI15_10_Handler,
-	(uint32_t) &RTC_Alarm_Handler,
-	(uint32_t) &OTG_FS_WKUP_Handler,
-	(uint32_t) &TIM8_BRK_TIM12_Handler,
-	(uint32_t) &TIM8_UP_TIM13_Handler,
-	(uint32_t) &TIM8_TRG_COM_TIM14_Handler,
-	(uint32_t) &TIM8_CC_Handler,
-	(uint32_t) &DMA1_Stream7_Handler,
-	(uint32_t) &FMC_Handler,
-	(uint32_t) &SDIO_Handler,
-	(uint32_t) &TIM5_Handler,
-	(uint32_t) &SPI3_Handler,
-	(uint32_t) &UART4_Handler,
-	(uint32_t) &UART5_Handler,
-	(uint32_t) &TIM6_DAC_Handler,
-	(uint32_t) &TIM7_Handler,
-	(uint32_t) &DMA2_Stream0_Handler,
-	(uint32_t) &DMA2_Stream1_Handler,
-	(uint32_t) &DMA2_Stream2_Handler,
-	(uint32_t) &DMA2_Stream3_Handler,
-	(uint32_t) &DMA2_Stream4_Handler,
-	0,
-	0,
-	(uint32_t) &CAN2_TX_Handler,
-	(uint32_t) &CAN2_RX0_Handler,
-	(uint32_t) &CAN2_RX1_Handler,
-	(uint32_t) &CAN2_SCE_Handler,
-	(uint32_t) &OTG_FS_Handler,
-	(uint32_t) &DMA2_Stream5_Handler,
-	(uint32_t) &DMA2_Stream6_Handler,
-	(uint32_t) &DMA2_Stream7_Handler,
-	(uint32_t) &USART6_Handler,
-	(uint32_t) &I2C3_EV_Handler,
-	(uint32_t) &I2C3_ER_Handler,
-	(uint32_t) &OTG_HS_EP1_OUT_Handler,
-	(uint32_t) &OTG_HS_EP1_IN_Handler,
-	(uint32_t) &OTG_HS_WKUP_Handler,
-	(uint32_t) &OTG_HS_Handler,
-	(uint32_t) &DCMI_Handler,
-	0,
-	0,
-	(uint32_t) &FPU_Handler,
-	0,
-	0,
-	(uint32_t) &SPI4_Handler,
-	0,
-	0,
-	(uint32_t) &SAI1_Handler,
-	0,
-	0,
-	0,
-	(uint32_t) &SAI2_Handler,
-	(uint32_t) &QuadSPI_Handler,
-	(uint32_t) &HDMI_CEC_Handler,
-	(uint32_t) &SPDIF_Rx_Handler,
-	(uint32_t) &FMPI2C1_Handler,
-	(uint32_t) &FMPI2C1_ERR_Handler
-};
+	(uint32_t)&Reset_Handler,
+	(uint32_t)&NMI_Handler,
+	(uint32_t)&HardFault_Handler,
+	(uint32_t)&MemManage_Handler,
+	(uint32_t)&BusFault_Handler,
+	(uint32_t)&UsageFault_Handler,
+	0,
+	0,
+	0,
+	0,
+	(uint32_t)&SVCall_Handler,
+	(uint32_t)&DebugMonitor_Handler,
+	0,
+	(uint32_t)&PendSV_Handler,
+	(uint32_t)&SysTick_Handler,
+	(uint32_t)&WWDG_Handler,
+	(uint32_t)&PVD_Handler,
+	(uint32_t)&TAMP_STAMP_Handler,
+	(uint32_t)&RTC_WKUP_Handler,
+	(uint32_t)&FLASH_Handler,
+	(uint32_t)&RCC_Handler,
+	(uint32_t)&EXTI0_Handler,
+	(uint32_t)&EXTI1_Handler,
+	(uint32_t)&EXTI2_Handler,
+	(uint32_t)&EXTI3_Handler,
+	(uint32_t)&EXTI4_Handler,
+	(uint32_t)&DMA1_Stream0_Handler,
+	(uint32_t)&DMA1_Stream1_Handler,
+	(uint32_t)&DMA1_Stream2_Handler,
+	(uint32_t)&DMA1_Stream3_Handler,
+	(uint32_t)&DMA1_Stream4_Handler,
+	(uint32_t)&DMA1_Stream5_Handler,
+	(uint32_t)&DMA1_Stream6_Handler,
+	(uint32_t)&ADC_Handler,
+	(uint32_t)&CAN1_TX_Handler,
+	(uint32_t)&CAN1_RX0_Handler,
+	(uint32_t)&CAN1_RX1_Handler,
+	(uint32_t)&CAN1_SCE_Handler,
+	(uint32_t)&EXTI9_5_Handler,
+	(uint32_t)&TIM1_BRK_TIM9_Handler,
+	(uint32_t)&TIM1_UP_TIM10_Handler,
+	(uint32_t)&TIM1_TRG_COM_TIM11_Handler,
+	(uint32_t)&TIM1_CC_Handler,
+	(uint32_t)&TIM2_Handler,
+	(uint32_t)&TIM3_Handler,
+	(uint32_t)&TIM4_Handler,
+	(uint32_t)&I2C1_EV_Handler,
+	(uint32_t)&I2C1_ER_Handler,
+	(uint32_t)&I2C2_EV_Handler,
+	(uint32_t)&I2C2_ER_Handler,
+	(uint32_t)&SPI1_Handler,
+	(uint32_t)&SPI2_Handler,
+	(uint32_t)&USART1_Handler,
+	(uint32_t)&USART2_Handler,
+	(uint32_t)&USART3_Handler,
+	(uint32_t)&EXTI15_10_Handler,
+	(uint32_t)&RTC_Alarm_Handler,
+	(uint32_t)&OTG_FS_WKUP_Handler,
+	(uint32_t)&TIM8_BRK_TIM12_Handler,
+	(uint32_t)&TIM8_UP_TIM13_Handler,
+	(uint32_t)&TIM8_TRG_COM_TIM14_Handler,
+	(uint32_t)&TIM8_CC_Handler,
+	(uint32_t)&DMA1_Stream7_Handler,
+	(uint32_t)&FMC_Handler,
+	(uint32_t)&SDIO_Handler,
+	(uint32_t)&TIM5_Handler,
+	(uint32_t)&SPI3_Handler,
+	(uint32_t)&UART4_Handler,
+	(uint32_t)&UART5_Handler,
+	(uint32_t)&TIM6_DAC_Handler,
+	(uint32_t)&TIM7_Handler,
+	(uint32_t)&DMA2_Stream0_Handler,
+	(uint32_t)&DMA2_Stream1_Handler,
+	(uint32_t)&DMA2_Stream2_Handler,
+	(uint32_t)&DMA2_Stream3_Handler,
+	(uint32_t)&DMA2_Stream4_Handler,
+	0,
+	0,
+	(uint32_t)&CAN2_TX_Handler,
+	(uint32_t)&CAN2_RX0_Handler,
+	(uint32_t)&CAN2_RX1_Handler,
+	(uint32_t)&CAN2_SCE_Handler,
+	(uint32_t)&OTG_FS_Handler,
+	(uint32_t)&DMA2_Stream5_Handler,
+	(uint32_t)&DMA2_Stream6_Handler,
+	(uint32_t)&DMA2_Stream7_Handler,
+	(uint32_t)&USART6_Handler,
+	(uint32_t)&I2C3_EV_Handler,
+	(uint32_t)&I2C3_ER_Handler,
+	(uint32_t)&OTG_HS_EP1_OUT_Handler,
+	(uint32_t)&OTG_HS_EP1_IN_Handler,
+	(uint32_t)&OTG_HS_WKUP_Handler,
+	(uint32_t)&OTG_HS_Handler,
+	(uint32_t)&DCMI_Handler,
+	0,
+	0,
+	(uint32_t)&FPU_Handler,
+	0,
+	0,
+	(uint32_t)&SPI4_Handler,
+	0,
+	0,
+	(uint32_t)&SAI1_Handler,
+	0,
+	0,
+	0,
+	(uint32_t)&SAI2_Handler,
+	(uint32_t)&QuadSPI_Handler,
+	(uint32_t)&HDMI_CEC_Handler,
+	(uint32_t)&SPDIF_Rx_Handler,
+	(uint32_t)&FMPI2C1_Handler,
+	(uint32_t)&FMPI2C1_ERR_Handler};
+
+void Reset_Handler(void)
+{
+	volatile uint32_t _bss_size = 0;
+	volatile uint32_t _data_size = 0;
+	volatile uint32_t _text_size = 0;
+	volatile uint32_t _heap_size = 0;
 
-void Reset_Handler(void){
 	uint32_t size = (uint32_t)&_edata - (uint32_t)&_sdata;
-	uint8_t *pDst = (uint8_t*)&_sdata;
-	uint8_t *pSrc = (uint8_t*)&_la_data;
-	for(uint32_t i=0;i<size;i++){
+	uint8_t *pDst = (uint8_t *)&_sdata;
+	uint8_t *pSrc = (uint8_t *)&_la_data;
+	for (uint32_t i = 0; i < size; i++)
+	{
 		*pDst++ = *pSrc++;
 	}
 	size = (uint32_t)&_ebss - (uint32_t)&_sbss;
-	pDst = (uint8_t*)&_sbss;
-	for(uint32_t i=0;i<size;i++){
+	pDst = (uint8_t *)&_sbss;
+
+	for (uint32_t i = 0; i < size; i++)
+	{
 		*pDst++ = 0;
 	}
 	_text_size = (uint32_t)&_etext - (uint32_t)&_stext;
 	_data_size = (uint32_t)&_edata - (uint32_t)&_sdata;
 	_bss_size = (uint32_t)&_ebss - (uint32_t)&_sbss;
-	kmain();
-}
-void Default_Handler(void){
-	while(1);
+	_heap_size = (uint32_t)&_eheap - (uint32_t)&_sheap; // should i do anything here??
+
+		kmain();
 }
-//2. implement the fault handlers
+
+// 2. implement the fault handlers
 void HardFault_Handler(void)
 {
-//	printf("Exception : Hardfault\n");
-	while(1);
+	// kprintf("Exception : Hardfault\n");
+	while (1)
+		;
 }
 
-
 void MemManage_Handler(void)
 {
-//	printf("Exception : MemManage\n");
-	while(1);
+	//	printf("Exception : MemManage\n");
+	while (1)
+		;
 }
 
 void BusFault_Handler(void)
 {
-//	printf("Exception : BusFault\n");
-	while(1);
+	//	printf("Exception : BusFault\n");
+	while (1)
+		;
 }
 
-void SVCall_Handler(void){
-/* Write code for SVC handler */
-/* the handler function evntually call syscall function with a call number */
-
+void SVCall_Handler(void)
+{
+	/* Write code for SVC handler */
+	/* the handler function evntually call syscall function with a call number */
+	uint32_t *args;
+
+	asm volatile(
+		"TST lr, #4\n"
+		"ITE EQ\n"
+		"MRSEQ r0, MSP\n"
+		"MRSNE r0, PSP\n"
+		"MOV %0, r0\n"
+		: "=r"(args)
+		:
+		:);
 
+	syscall(args);
 }
-
-
diff -ruN duos24/src/kern/include/UsartRingBuffer.h duos24_1/src/kern/include/UsartRingBuffer.h
--- duos24/src/kern/include/UsartRingBuffer.h	2025-03-20 15:35:29.075514300 +0600
+++ duos24_1/src/kern/include/UsartRingBuffer.h	2025-03-16 18:28:20.847790800 +0600
@@ -125,6 +125,18 @@
 
 int32_t update_tail(UART_HandleTypeDef *,uint32_t);
 
+
+
+
+/*later added by faiak */
+void DRV_USART_INIT(USART_TypeDef* usart);
+void UART_SendChar(USART_TypeDef *usart,uint8_t c);
+void _USART_WRITE(USART_TypeDef *usart,uint8_t *s);
+uint8_t _USART_READ(USART_TypeDef* usart,uint8_t *buff,uint16_t size);
+uint8_t UART_GetChar(USART_TypeDef *usart);
+uint8_t _USART_READ_STR(USART_TypeDef* usart,uint8_t *buff,uint16_t size);
+
+
 void debug_buffer(UART_HandleTypeDef *);
 #ifdef __cplusplus
 }
diff -ruN duos24/src/kern/include/kern/kunistd.h duos24_1/src/kern/include/kern/kunistd.h
--- duos24/src/kern/include/kern/kunistd.h	2025-03-20 15:35:29.397715200 +0600
+++ duos24_1/src/kern/include/kern/kunistd.h	2025-03-16 18:28:21.131910100 +0600
@@ -34,5 +34,21 @@
 #define STDIN_FILENO  0      /* Standard input */
 #define STDOUT_FILENO 1      /* Standard output */
 #define STDERR_FILENO 2      /* Standard error */
+
+#include <stdint.h>
+#include <types.h>
+#include <kmain.h>
+#include <cm4.h>
+#include <sys_init.h>
+
+void *heap_malloc(uint32_t size);
+void heap_free(void *ptr);
+
+void __sys_start_task(uint32_t psp);
+
+int __sys_fork(uint32_t* parents_psp);
+
+int __sys_execv(char *filename, char *argv[], char *envp[]);
+
 #endif /* KERN_UNISTD_H */
 
diff -ruN duos24/src/kern/include/kern/sys_init.h duos24_1/src/kern/include/kern/sys_init.h
--- duos24/src/kern/include/kern/sys_init.h	2025-03-20 15:35:29.294461200 +0600
+++ duos24_1/src/kern/include/kern/sys_init.h	2025-03-16 18:28:21.037391600 +0600
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 
+ * Copyright (c) 2022
  * Computer Science and Engineering, University of Dhaka
  * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
  *
@@ -27,22 +27,48 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
- 
+
 #ifndef __SYS_INIT_H
 #define __SYS_INIT_H
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
-#include<stdint.h>
+#include <stdint.h>
+
+    /* by faiak */
+
+    extern uint32_t _sheap;
+    extern uint32_t _eheap;
+
+    typedef struct heap_chunk
+    {
+        int size;
+        int isUse;
+        struct heap_chunk *next;
+    } heap_chunk;
+
+    typedef struct heap_info
+    {
+        heap_chunk *start;
+        heap_chunk *curr;
 
-#define SET_ACT_DEV(QUEUE,DEV)  (QUEUE |= DEV)
-void __sys_init(void); 
-void SoftReset(void);
-uint32_t verify_connectivity(void);
+        heap_chunk *free_list;
+        uint32_t available;
+    } heap_info;
+
+    extern heap_info *heap;
+
+    void heap_init(void);
+
+/********** */
+#define SET_ACT_DEV(QUEUE, DEV) (QUEUE |= DEV)
+    void __sys_init(void);
+    void SoftReset(void);
+    uint32_t verify_connectivity(void);
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* SYS_INIT */
-
diff -ruN duos24/src/kern/include/kern/syscall_def.h duos24_1/src/kern/include/kern/syscall_def.h
--- duos24/src/kern/include/kern/syscall_def.h	2025-03-20 15:35:29.341085600 +0600
+++ duos24_1/src/kern/include/kern/syscall_def.h	2025-03-16 18:28:21.089202000 +0600
@@ -150,6 +150,11 @@
 //-- Other reboot scheduling etc. --
 #define SYS_sync         118
 #define SYS_reboot       119
-#define SYS_yield        120	
+#define SYS_yield        120
+#define SYS_start        121
+#define SYS_set_pending  122
+
+#define SYS_malloc      123
+#define SYS_free         124
 
 #endif /*End of SYSCALL_DEF_H */
diff -ruN duos24/src/kern/include/kern/types.h duos24_1/src/kern/include/kern/types.h
--- duos24/src/kern/include/kern/types.h	2025-03-20 15:35:29.364256100 +0600
+++ duos24_1/src/kern/include/kern/types.h	2025-03-16 18:28:21.100484600 +0600
@@ -96,7 +96,7 @@
 typedef struct task_tcb{
 	uint32_t magic_number; //here it is 0xFECABAA0
 	uint16_t task_id; //a unsigned 16 bit integer starting from 1000 
-	void *psp; //task stack pointer or stackframe address
+	uint32_t *psp; //task stack pointer or stackframe address
 	uint16_t status; //task status: running, waiting, ready, killed, or terminated
 	uint32_t execution_time; //total execution time (in ms)
 	uint32_t waiting_time; //total waiting time (in ms)
diff -ruN duos24/src/kern/include/kmain.h duos24_1/src/kern/include/kmain.h
--- duos24/src/kern/include/kmain.h	2025-03-20 15:35:29.189702300 +0600
+++ duos24_1/src/kern/include/kmain.h	2025-03-16 18:28:20.942264800 +0600
@@ -55,6 +55,56 @@
 
 #define INTERRUPT_ENABLE()  do{__asm volatile ("MOV R0,#0x0"); asm volatile("MSR PRIMASK,R0"); } while(0)
 
+//by FAIAK
+#define RUNNING 0
+#define WAITING 1
+#define READY 2
+#define KILLED 3
+#define TERMINATED 4
+
+
+extern volatile uint16_t  TASK_ID;
+const static uint32_t MAGIC_NUMBER = 0xFECABAA0;
+const static uint32_t DIGITAL_SIGNATURE = 0x00000001; 
+
+#define MAX_QUEUE_SIZE_P  5
+
+
+extern volatile uint32_t QUEUE_SIZE_P ;
+extern volatile uint32_t CURR_TASK_P ;
+
+extern volatile TCB_TypeDef READY_QUEUE[MAX_QUEUE_SIZE_P];
+
+void create_tcb(TCB_TypeDef *tcb, void(*func_ptr)(void), uint32_t* stack_start);
+
+
+
+
+#define O_RDONLY 0
+#define O_WRONLY 1
+#define O_APPEND 2
+
+/* Constants for read/write/etc: special file handles */
+#define STDIN_FILENO  0      /* Standard input */
+#define STDOUT_FILENO 1      /* Standard output */
+#define STDERR_FILENO 2      /* Standard error */
+
+#define MAX_FILES 64
+
+typedef struct file_entry {
+    char name[32];     // File name
+    uint32_t *address; // Memory-mapped file location
+    uint32_t size;     // File size in bytes
+    uint8_t mode;      // File mode
+} file_entry_t;
+
+
+extern volatile file_entry_t file_list[MAX_FILES];
+extern volatile uint32_t file_count;
+
+int find_file(char *filename);
+
+
 #ifdef __cplusplus
 }
 #endif
diff -ruN duos24/src/kern/include/sys_call.h duos24_1/src/kern/include/sys_call.h
--- duos24/src/kern/include/sys_call.h	1970-01-01 06:00:00.000000000 +0600
+++ duos24_1/src/kern/include/sys_call.h	2025-03-16 18:28:20.926386100 +0600
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2022 
+ * Computer Science and Engineering, University of Dhaka
+ * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+ 
+#ifndef _SYSCALL_H
+#define _SYSCALL_H
+#include <stdint.h>
+#include <syscall_def.h>
+#include <kunistd.h>
+#include <types.h>
+#include <kstdio.h>
+#include <cm4.h>
+#include <kmain.h>
+#include <stdarg.h>
+#include <system_config.h>
+#include <sys_bus_matrix.h>
+
+void syscall(uint32_t *args);
+#endif
+
diff -ruN duos24/src/kern/include/syscall.h duos24_1/src/kern/include/syscall.h
--- duos24/src/kern/include/syscall.h	2025-03-20 15:35:29.170869700 +0600
+++ duos24_1/src/kern/include/syscall.h	1970-01-01 06:00:00.000000000 +0600
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2022 
- * Computer Science and Engineering, University of Dhaka
- * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
- 
-#ifndef _SYSCALL_H
-#define _SYSCALL_H
-#include <stdint.h>
-void syscall(uint16_t);
-#endif
-
diff -ruN duos24/src/kern/kmain/kmain.c duos24_1/src/kern/kmain/kmain.c
--- duos24/src/kern/kmain/kmain.c	2025-03-20 15:35:28.789722100 +0600
+++ duos24_1/src/kern/kmain/kmain.c	2025-03-20 15:31:57.440467700 +0600
@@ -36,14 +36,702 @@
 #include <kstdio.h>
 #include <sys_rtc.h>
 #include <kstring.h>
+#include <stm32_startup.h>
+#include <syscall_def.h>
+#include <types.h>
+#include <times.h>
+#include <unistd.h>
 #ifndef DEBUG
 #define DEBUG 1
 #endif
+
+/*
+typedef struct task_tcb{
+    uint32_t magic_number; //here it is 0xFECABAA0
+    uint16_t task_id; //a unsigned 16 bit integer starting from 1000
+    void *psp; //task stack pointer or stackframe address
+    uint16_t status; //task status: running, waiting, ready, killed, or terminated
+    uint32_t execution_time; //total execution time (in ms)
+    uint32_t waiting_time; //total waiting time (in ms)
+    uint32_t digital_sinature; //current value is 0x00000001
+}TCB_TypeDef;
+
+*/
+
+/****************** ********************/
+
+volatile uint32_t QUEUE_SIZE_P = 3;
+volatile uint32_t CURR_TASK_P = 0;
+volatile uint16_t TASK_ID = 1000;
+
+volatile TCB_TypeDef READY_QUEUE[MAX_QUEUE_SIZE_P];
+
+// void PUSH_tcb(TCB_TypeDef* tcb, void(*func_ptr)(void))
+// {
+//     for (uint32_t i = 0; i < QUEUE_SIZE_P; i++)
+//     {
+
+//         if (READY_QUEUE[i].task_id == tcb->task_id)
+//         {
+//             break;
+//         }
+//         else if (i == QUEUE_SIZE_P - 1)
+//         {
+//             kprintf("Queue is full\n");
+//             return;
+//         }
+//         else if(READY_QUEUE[i].status == KILLED || READY_QUEUE[i].status == TERMINATED)
+//         {
+//             create_tcb(READY_QUEUE + i, (void*) func_ptr, tcb->psp);
+//             break;
+//         }
+//     }
+// }
+// void POP_tcb(TCB_TypeDef* tcb)
+// {
+//     for (uint32_t i = 0; i < QUEUE_SIZE_P; i++)
+//     {
+//         if (READY_QUEUE[i] == tcb)
+//         {
+//             READY_QUEUE[i] = NULL;
+//             break;
+//         }
+//     }
+// }
+
+void create_tcb(TCB_TypeDef *tcb, void (*func_ptr)(void), uint32_t *stack_start)
+{
+    tcb->magic_number = MAGIC_NUMBER;
+    tcb->task_id = TASK_ID;
+    TASK_ID++;
+    tcb->status = READY;
+    tcb->execution_time = 0;
+    tcb->waiting_time = 0;
+    tcb->digital_sinature = DIGITAL_SIGNATURE;
+
+    tcb->psp = stack_start;
+    *(--tcb->psp) = 0x01000000;         // xPSR
+    *(--tcb->psp) = (uint32_t)func_ptr; // PC
+    *(--tcb->psp) = 0xFFFFFFFD;         // LR
+
+    for (uint32_t i = 0; i < 13; i++)
+    {
+        *(--tcb->psp) = 0;
+    }
+
+    __ISB();
+}
+
+/**************** *********************/
+
+uint32_t *psp_stack_addresses[2];
+uint32_t size = 2;
+uint32_t CURR_TASK = 0;
+
+void __set_user_mode(void)
+{
+
+    uint32_t psp_stack[1024];
+    PSP_Init(psp_stack + 1024);
+    asm volatile(
+        ".global PSP_Init\n"
+        "PSP_Init:\n"
+        "msr psp, r0\n"
+        "mov r0, #3\n"
+        "msr control, r0\n"
+        "isb 0xf\n"
+        :
+        :
+        : "memory");
+}
+
+// attribute = naked -> active
+// attribute = weak -> not active
+// #ifndef RR
+// #define RR
+// void __attribute__((naked)) PendSV_Handler(void)
+// {
+//     // Clear all pending interrupts
+//     SCB->ICSR |= (1 << 27);
+
+//     // kprintf("PendSV_Handler\n");
+
+//     // save current context
+//     asm volatile(
+//         "mrs r0, psp\n"
+//         "isb 0xf\n"
+//         "stmdb r0!, {r4-r11}\n");
+
+//     asm volatile("mov %0, r0\n"
+//                  : "=r"(psp_stack_addresses[CURR_TASK])
+//                  :);
+
+//     __DSB();
+//     __ISB();
+//     /*---------------------------------------------*/
+
+//     CURR_TASK = (CURR_TASK + 1) % size;
+
+//     asm volatile(
+//         "mov r0, %0"
+//         :
+//         : "r"((uint32_t)psp_stack_addresses[CURR_TASK]));
+//     asm volatile(
+//         "ldmia r0!,{r4-r11}\n"
+//         "msr psp, r0\n"
+//         "isb 0xf\n"
+//         "bx lr\n");
+// }
+// #endif
+
+void __attribute__((noreturn)) sleep_state(void)
+{
+    // set_pending(0);
+
+    __set_pending(0);
+
+    while (1)
+    {
+        __WFI(); // Wait For Interrupt (Stops CPU Until An Interrupt Occurs)
+    }
+}
+
+#ifndef RR
+#define RR
+void __attribute__((naked)) PendSV_Handler(void)
+{
+    // Clear all pending interrupts
+    SCB->ICSR |= (1 << 27);
+
+    // kprintf("PendSV_Handler\n");
+
+    // save current context
+    if (READY_QUEUE[CURR_TASK_P].status == RUNNING)
+    {
+        READY_QUEUE[CURR_TASK_P].status = READY;
+        asm volatile(
+            "mrs r0, psp\n"
+            "isb 0xf\n"
+            "stmdb r0!, {r4-r11}\n");
+
+        asm volatile("mov %0, r0\n"
+                     : "=r"(READY_QUEUE[CURR_TASK_P].psp)
+                     :);
+    }
+    __DSB();
+    __ISB();
+    /*---------------------------------------------*/
+
+    // CURR_TASK_P = (CURR_TASK_P + 1) % QUEUE_SIZE_P;
+
+    uint32_t chosen_task = MAX_QUEUE_SIZE_P;
+    uint32_t count = 0;
+
+    for (int i = (CURR_TASK_P + 1) % QUEUE_SIZE_P;; i = (i + 1) % QUEUE_SIZE_P)
+    {
+
+        if (READY_QUEUE[i].status == READY)
+        {
+            chosen_task = i;
+            break;
+        }
+
+        count++;
+
+        if (count >= MAX_QUEUE_SIZE_P)
+        {
+            break;
+        }
+    }
+
+    if (chosen_task == 5)
+    { // finished
+
+        // while(1);
+        // uint32_t new_psp_stack[1024];
+        // uint32_t* new_psp = (uint32_t*) new_psp_stack + 1024;
+        // *(--new_psp) = 0x01000000;      // xPSR
+        // *(--new_psp) = (uint32_t)sleep_state; // PC
+        // *(--new_psp) = 0xFFFFFFFD;      // LR
+
+        // for (uint32_t i = 0; i < 13; i++)
+        // {
+        //     *(--new_psp) = 0;
+        // }
+
+        __set_pending(0);
+        // __asm volatile(
+        //     "mov r0, %0\n"
+        //     "msr psp, r0\n"
+        //     "isb 0xf\n"
+        //     :
+        //     : "r" (new_psp)
+        // );
+
+        __DSB();
+        __ISB();
+
+        // __asm volatile("bx lr\n");
+        // sleep_state();
+
+        asm volatile("bl sleep_state");
+    }
+    else
+    {
+        CURR_TASK_P = chosen_task;
+    }
+
+    __DSB();
+    __ISB();
+
+    asm volatile(
+        "mov r0, %0"
+        :
+        : "r"((uint32_t)READY_QUEUE[CURR_TASK_P].psp));
+
+    READY_QUEUE[CURR_TASK_P].status = RUNNING;
+
+    asm volatile(
+        "ldmia r0!,{r4-r11}\n"
+        "msr psp, r0\n"
+        "isb 0xf\n"
+        "bx lr\n");
+}
+#endif
+
+// target extended-remote localhost:3333
+
+void yield(void)
+{
+    __ISB();
+
+    asm volatile("PUSH {r4-r11}");
+    asm volatile("svc %0" : : "i"(SYS_yield));
+    asm volatile("POP {r4-r11}");
+    __ISB();
+}
+
+void task_exit(void)
+{
+    // READY_QUEUE[CURR_TASK_P].status = KILLED;
+
+    __ISB();
+
+    TCB_TypeDef *tcb = READY_QUEUE + CURR_TASK_P;
+    __asm volatile(
+        "MOV R2, %0\n"
+        :
+        : "r"(tcb));
+    asm volatile("PUSH {r4-r11}");
+    asm volatile("svc %0" : : "i"(SYS__exit));
+    asm volatile("POP {r4-r11}");
+
+    kprintf("task exited : %d\n", READY_QUEUE[CURR_TASK_P].task_id);
+
+    __DSB();
+    __ISB();
+
+    yield();
+}
+
+void task0(void)
+{
+    for (uint32_t i = 0; i < 100; i++)
+    {
+        kprintf("Task Number 0 call %d\n", i);
+    }
+
+    kprintf("Task Number 0 finished\n");
+
+    // while(1);
+    task_exit();
+
+    while (1)
+        ;
+}
+
+void task1(void)
+{
+    for (uint32_t i = 0; i < 100; i++)
+    {
+        kprintf("Task Number 1 call %d\n", i);
+    }
+
+    kprintf("Task Number 1 finished\n");
+    task_exit();
+
+    while (1)
+        ;
+}
+
+void task2(void)
+{
+    for (uint32_t i = 0; i < 100; i++)
+    {
+        kprintf("Task Number 2 call %d\n", i);
+    }
+
+    kprintf("Task Number 2 finished\n");
+    task_exit();
+
+    while (1)
+        ;
+}
+
+void task_for_fork(void)
+{
+
+    kprintf("Inside task for fork\n");
+
+    int pid = fork(&pid); // pc
+    if (pid == 0)
+    {
+        kprintf("child process\n");
+        kprintf("pid returned: %d\n", pid);
+        // while(1);
+    }
+    else
+    {
+
+        kprintf("parent process\n");
+        kprintf("pid returned: %d\n", pid);
+
+        // while(1);
+    }
+
+    task_exit();
+}
+
+void init_scheduler_for_fork(void)
+{
+    CURR_TASK_P = 0;
+    QUEUE_SIZE_P = 1;
+
+    uint32_t psp_parent_task[1024];
+
+    create_tcb(READY_QUEUE + CURR_TASK_P, (void *)task_for_fork, (uint32_t *)(psp_parent_task + 1024));
+    QUEUE_SIZE_P++;
+
+    // __set_pending(1);
+
+    READY_QUEUE[CURR_TASK_P].status = RUNNING;
+
+    // kprintf("pid : %d\n", READY_QUEUE[CURR_TASK_P].task_id);
+
+    start_task((uint32_t)(READY_QUEUE[CURR_TASK_P].psp));
+}
+
+void start_task(uint32_t psp)
+{
+
+    asm volatile("MOV R0, %0"
+                 :
+                 : "r"(psp));
+    asm volatile("PUSH {r4-r11}");
+    asm volatile("svc %0" : : "i"(SYS_start));
+    asm volatile("POP {r4-r11}");
+}
+
+void set_pending(uint8_t value)
+{
+    asm volatile("MOV R0, %0"
+                 :
+                 : "r"(value));
+    asm volatile("PUSH {r4-r11}");
+    asm volatile("svc %0" : : "i"(SYS_set_pending));
+    asm volatile("POP {r4-r11}");
+}
+
+int getPID(void)
+{
+    int pid = 0;
+    asm volatile("PUSH {r4-r11}");
+    asm volatile("svc %0" : : "i"(SYS_getpid));
+    asm volatile("POP {r4-r11}");
+
+    asm volatile("MOV %0, R0"
+                 : "=r"(pid));
+
+    return pid;
+}
+
+int fork(uint32_t *pid)
+{
+
+    *(pid) = (uint32_t)0;
+
+    asm volatile("PUSH {r4-r11}");
+    asm volatile("svc %0" : : "i"(SYS_fork));
+    asm volatile("POP {r4-r11}");
+
+    asm volatile("MOV R0, 0");
+
+    // yield(); // i want to return to here after fork of child process
+
+    __DSB();
+    __ISB();
+
+    asm volatile("MOV %0, R2"
+                 : "=r"(*pid));
+
+    if (CURR_TASK_P == 0)
+    {
+        return *pid;
+    }
+    else
+    {
+        *pid = 0;
+        return 0;
+    }
+
+    return *pid;
+}
+
+void init_tasks(void)
+{
+
+    uint64_t psp0_stack[1024], psp1_stack[1024];
+
+    psp_stack_addresses[0] = psp0_stack + 1024;
+
+    kprintf("psp0_stack: %x\n", psp_stack_addresses[0]);
+    *(--psp_stack_addresses[0]) = 0x01000000;      // xPSR
+    *(--psp_stack_addresses[0]) = (uint32_t)task0; // PC
+    *(--psp_stack_addresses[0]) = 0xFFFFFFFD;      // LR
+
+    for (uint32_t i = 0; i < 13; i++)
+    {
+        *(--psp_stack_addresses[0]) = 0;
+    }
+
+    kprintf("psp0_stack: %x\n", psp_stack_addresses[0]);
+
+    psp_stack_addresses[1] = psp1_stack + 1024;
+    *(--psp_stack_addresses[1]) = 0x01000000;      // xPSR
+    *(--psp_stack_addresses[1]) = (uint32_t)task1; // PC
+    *(--psp_stack_addresses[1]) = 0xFFFFFFFD;      // LR
+
+    for (uint32_t i = 0; i < 13; i++)
+    {
+        *(--psp_stack_addresses[1]) = 0;
+    }
+
+    set_pending(1);
+
+    start_task(psp_stack_addresses[CURR_TASK]);
+}
+
+void init_scheduler(void)
+{
+    uint64_t psp0_stack[1024], psp1_stack[1024], psp2_stack[1024];
+
+    kprintf("psp0_stack: %x\n", psp0_stack + 1024);
+    kprintf("psp1_stack: %x\n", psp1_stack + 1024);
+    kprintf("psp2_stack: %x\n", psp2_stack + 1024);
+
+    create_tcb(READY_QUEUE + CURR_TASK_P, (void *)task0, psp0_stack + 1024);
+    CURR_TASK_P = (CURR_TASK_P + 1) % QUEUE_SIZE_P;
+    create_tcb(READY_QUEUE + CURR_TASK_P, (void *)task1, psp1_stack + 1024);
+    CURR_TASK_P = (CURR_TASK_P + 1) % QUEUE_SIZE_P;
+    create_tcb(READY_QUEUE + CURR_TASK_P, (void *)task2, psp2_stack + 1024);
+    CURR_TASK_P = (CURR_TASK_P + 1) % QUEUE_SIZE_P;
+
+    kprintf("psp0_stack: %x\n", READY_QUEUE[0].psp);
+    kprintf("psp1_stack: %x\n", READY_QUEUE[1].psp);
+    kprintf("psp2_stack: %x\n", READY_QUEUE[2].psp);
+
+    set_pending(1);
+
+    READY_QUEUE[CURR_TASK_P].status = RUNNING;
+
+    start_task((uint32_t)(READY_QUEUE[CURR_TASK_P].psp));
+}
+
+///// for execve /////
+
+volatile file_entry_t file_list[MAX_FILES];
+volatile uint32_t file_count = 0;
+
+int find_file(char *filename)
+{
+    for (uint32_t i = 0; i < file_count; i++)
+    {
+        if (strcomp((uint8_t *)file_list[i].name, (uint8_t *)filename) == 0)
+        {
+            return i;
+        }
+    }
+    return -1;
+}
+
+int execve(char *filename, char *argv[], char *envp[])
+{
+    int return_val = 0;
+    __asm volatile(
+        "mov r0, %0\n"
+        "mov r1, %1\n"
+        "mov r2, %2\n"
+        "push {r4,r11}\n"
+        "svc %4\n"
+        "pop {r4,r11}\n"
+        "mov %3, r0\n"
+        : "=r"(filename), "=r"(argv), "=r"(envp), "=r"(return_val)
+        : "i"(SYS_execv));
+
+    return return_val;
+}
+
+void file_A(void)
+{
+    kprintf("Task A initiated\n");
+
+    char *argv[] = {"PRINT_B", "Hello World", NULL};
+    char *envp[] = {NULL};
+
+    int ret = execve(argv[0], argv, envp);
+
+    if (ret == -1)
+    {
+        kprintf("execve failed\n");
+    }
+
+    kprintf("A finished\n");
+    task_exit();
+}
+
+void file_B(void)
+{
+    kprintf("Task B Initiated\n");
+
+    kprintf("Task B finished\n"); // should not be printed
+    task_exit();
+}
+
+void file_C(void)
+{
+    kprintf("Task C Initiated\n");
+
+    kprintf("Task C finished\n"); // should not be printed
+    task_exit();
+}
+
+void init_file_system(void)
+{
+    file_entry_t file1;
+    file1.address = (uint32_t *)file_B;
+    file1.size = 1024;
+    file1.mode = O_RDONLY;
+    strcopy((uint8_t *)file1.name, (const uint8_t *)"PRINT_B");
+    file_list[file_count++] = file1;
+
+    file_entry_t file2;
+    file2.address = (uint32_t *)file_C;
+    file2.size = 1024;
+    file2.mode = O_RDONLY;
+    strcopy((uint8_t *)file2.name, (const uint8_t *)"PRINT_C");
+    file_list[file_count++] = file2;
+
+    __ISB();
+}
+
+void init_task_for_execv(void)
+{
+    QUEUE_SIZE_P = 1;
+    CURR_TASK_P = 0;
+
+    uint32_t psp_stack[1024];
+
+    create_tcb(READY_QUEUE + CURR_TASK_P, (void *)file_A, psp_stack + 1024);
+
+    READY_QUEUE[CURR_TASK_P].status = RUNNING;
+
+    start_task((uint32_t)(READY_QUEUE[CURR_TASK_P].psp));
+}
+
 void kmain(void)
 {
     __sys_init();
+
+    init_file_system();
+
+    __NVIC_SetPriority(SVCall_IRQn, 0x1);
+    NVIC_EnableIRQ(SVCall_IRQn);
+    __NVIC_SetPriority(PendSV_IRQn, 0xFF);
+    NVIC_EnableIRQ(PendSV_IRQn);
+    __NVIC_SetPriority(SysTick_IRQn, 0xFF);
+    NVIC_EnableIRQ(SysTick_IRQn);
+
+    __ISB();
+
+    kprintf("OS Started\n");
+
+    __set_user_mode();
+
+    // umain();
+
+    // char c;
+    // kscanf("%c", &c);
+
+    // kprintf("You entered: %c\n", c);
+
+    // init_tasks();
+
+    // init_scheduler(); // round robin scheduler /// for a round robin example
+
+    // init_scheduler_for_fork(); // for a forking example
+
+    // init_task_for_execv(); // for execv example
+
+    typedef struct student
+    {
+        char name[20];
+        int roll;
+        char dept[20];
+        float cgpa;
+    } student;
+
+    student *s1 = (struct student *)du_malloc(sizeof(student));
+    s1->roll = 1;
+    s1->cgpa = 4.00;
+
+    // Copying string manually without using strcpy
+    char dept[] = "Computer Science";
+    char name[] = "Faiak";
+
+    for (int i = 0; i < sizeof(dept) && i < sizeof(s1->dept); i++)
+    {
+        s1->dept[i] = dept[i];
+    }
+
+    for (int i = 0; i < sizeof(name) && i < sizeof(s1->name); i++)
+    {
+        s1->name[i] = name[i];
+    }
+
+    kprintf("Student Name: %s\n", s1->name);
+    kprintf("Student Department: %s\n", s1->dept);
+    kprintf("Student Roll: %d\n", s1->roll);
+    kprintf("Student CGPA: %f\n", s1->cgpa);
+
+    du_free(s1);
+
+    kprintf("Student Name: %s\n", s1->name);
+    kprintf("Student Department: %s\n", s1->dept);
+    kprintf("Student Roll: %d\n", s1->roll);
+    kprintf("Student CGPA: %f\n", s1->cgpa);
+
+    // uint8_t *ptr = du_malloc(20);
+
+    // kprintf("ptr: %x\n", ptr);
+
+    // char c;
+    // du_scanf("%c", &c);
+
+    // du_printf("You entered: %c\n", c);
+
+    // du_printf("Hello from userland\n");
+
     while (1)
     {
-      
     }
 }
diff -ruN duos24/src/kern/lib/UsartRingBuffer.c duos24_1/src/kern/lib/UsartRingBuffer.c
--- duos24/src/kern/lib/UsartRingBuffer.c	2025-03-20 15:35:28.858862300 +0600
+++ duos24_1/src/kern/lib/UsartRingBuffer.c	2025-03-16 18:28:20.642737600 +0600
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 
+ * Copyright (c) 2022
  * Computer Science and Engineering, University of Dhaka
  * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
  *
@@ -27,7 +27,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
- 
+
 #include <UsartRingBuffer.h>
 #include <sys_usart.h>
 #include <serial_lin.h>
@@ -37,7 +37,6 @@
 #include <cm4.h>
 #include <cmd_def.h>
 
-
 /*  Define the device uart and pc uart below according to your setup  */
 
 /* put the following in the ISR
@@ -56,7 +55,6 @@
 	__UART_ENABLE_IT(huart, UART_IT_ERR);
 	/* Enable the UART Data Register not empty Interrupt */
 	__UART_ENABLE_IT(huart, UART_IT_RXNE);
-	
 }
 
 void static store_char(unsigned char c, UART_HandleTypeDef *huart)
@@ -64,11 +62,13 @@
 	ring_buffer *buffer = huart->pRxBuffPtr;
 	uint32_t buff_size = huart->RxXferSize;
 	unsigned int i = 0;
-	if((buffer->head + 1) == buff_size) 
+	if ((buffer->head + 1) == buff_size)
+	{
+		i = 0;
+	}
+	else
 	{
-		i=0;
-	}else{
-		i=buffer->head + 1;
+		i = buffer->head + 1;
 	}
 	// if we should be storing the received character into the location
 	// just before the tail (meaning that the head would advance to the
@@ -226,18 +226,27 @@
 	unsigned int i;
 	if (c >= 0)
 	{
-		if((uart->pTxBuffPtr->head + 1) == uart->TxXferSize)
+		if ((uart->pTxBuffPtr->head + 1) == uart->TxXferSize)
 		{
-			i =0 ;
-		}else
+			i = 0;
+		}
+		else
 		{
-			i=uart->pTxBuffPtr->head + 1;
+			i = uart->pTxBuffPtr->head + 1;
 		}
 
 		// If the output buffer is full, there's nothing for it other than to
 		// wait for the interrupt handler to empty it a bit
 		// ???: return 0 here instead?
-		while (i == uart->pTxBuffPtr->tail);
+
+		// if (i == uart->pTxBuffPtr->tail)
+		// {
+		// 	// kprintf("Uart buffer full, dropping character: %c\n", c);
+		// 	return; // Drop the character instead of hanging
+		// }
+
+		while (i == uart->pTxBuffPtr->tail)
+			;
 
 		uart->pTxBuffPtr->buffer[uart->pTxBuffPtr->head] = (uint8_t)c;
 		uart->pTxBuffPtr->head = i;
@@ -342,16 +351,16 @@
 {
 	int so_far = 0;
 	int len = (int)__strlen((uint8_t *)string);
-	uint32_t c_time=__getTime();
+	uint32_t c_time = __getTime();
 again_device:
 	while (!IsDataAvailable(uart))
 	{
-		#ifdef MS_TIMEOUT
-			if((__getTime()-c_time) >= MS_TIMEOUT*1000)
-			{
-				return SYS_TIMEOUT;
-			} 
-		#endif
+#ifdef MS_TIMEOUT
+		if ((__getTime() - c_time) >= MS_TIMEOUT * 1000)
+		{
+			return SYS_TIMEOUT;
+		}
+#endif
 	}
 	if (Uart_peek(uart) != string[so_far])
 	{
@@ -366,12 +375,12 @@
 			return 1;
 		while (!IsDataAvailable(uart))
 		{
-		#ifdef MS_TIMEOUT
-			if((__getTime()-c_time) >= MS_TIMEOUT*1000)
+#ifdef MS_TIMEOUT
+			if ((__getTime() - c_time) >= MS_TIMEOUT * 1000)
 			{
 				return SYS_TIMEOUT;
-			} 
-		#endif
+			}
+#endif
 		}
 	}
 
@@ -387,25 +396,24 @@
 		return 0;
 }
 
-int look_for_frame(char *string, UART_HandleTypeDef *uart,uint32_t timeout,uint8_t *target)
+int look_for_frame(char *string, UART_HandleTypeDef *uart, uint32_t timeout, uint8_t *target)
 {
 	int so_far = 0;
 	uint8_t c;
 	uint32_t j;
 	int len = (int)__strlen((uint8_t *)string);
-	uint32_t c_time=__getTime();
+	uint32_t c_time = __getTime();
 again_device:
-	j=0;
+	j = 0;
 	while (!IsDataAvailable(uart))
 	{
-		if(timeout>0)
+		if (timeout > 0)
 		{
-			if((__getTime()-c_time) >= timeout)
+			if ((__getTime() - c_time) >= timeout)
 			{
 				return SYS_TIMEOUT;
-			} 
+			}
 		}
-		
 	}
 	if (Uart_peek(uart) != string[so_far])
 	{
@@ -415,29 +423,32 @@
 	while (Uart_peek(uart) == string[so_far])
 	{
 		so_far++;
-		c=Uart_read(uart);
-		target[j]=c;
+		c = Uart_read(uart);
+		target[j] = c;
 		j++;
 		if (so_far == len)
 		{
-			while (!IsDataAvailable(uart));
-			while(Uart_peek(uart)!='\n'){
-				c=Uart_read(uart);
-				target[j]=c;
+			while (!IsDataAvailable(uart))
+				;
+			while (Uart_peek(uart) != '\n')
+			{
+				c = Uart_read(uart);
+				target[j] = c;
 				j++;
-				while (!IsDataAvailable(uart));
+				while (!IsDataAvailable(uart))
+					;
 			}
-			target[j]=0;
+			target[j] = 0;
 			return 1;
 		}
 		while (!IsDataAvailable(uart))
 		{
-			if(timeout>0)
+			if (timeout > 0)
 			{
-				if((__getTime()-c_time) >= timeout)
+				if ((__getTime() - c_time) >= timeout)
 				{
-				return SYS_TIMEOUT;
-				} 
+					return SYS_TIMEOUT;
+				}
 			}
 		}
 	}
@@ -445,7 +456,7 @@
 	if (so_far != len)
 	{
 		so_far = 0;
-		j=0;
+		j = 0;
 		goto again_device;
 	}
 
@@ -453,13 +464,12 @@
 		return 1;
 	else
 	{
-		target[0]=0;
+		target[0] = 0;
 		return 0;
 	}
 }
 
-void 
-Uart_isr(UART_HandleTypeDef *huart)
+void Uart_isr(UART_HandleTypeDef *huart)
 {
 	uint32_t isrflags = READ_REG(huart->Instance->SR);
 	uint32_t cr1its = READ_REG(huart->Instance->CR1);
@@ -508,13 +518,14 @@
 		{
 			// There is more data in the output buffer. Send the next byte
 			c = huart->pTxBuffPtr->buffer[huart->pTxBuffPtr->tail];
-			if(huart->pTxBuffPtr->tail+1 == huart->TxXferSize)
+			if (huart->pTxBuffPtr->tail + 1 == huart->TxXferSize)
 			{
-				huart->pTxBuffPtr->tail=0;
-			}else{
-				huart->pTxBuffPtr->tail = (huart->pTxBuffPtr->tail + 1)	;
+				huart->pTxBuffPtr->tail = 0;
+			}
+			else
+			{
+				huart->pTxBuffPtr->tail = (huart->pTxBuffPtr->tail + 1);
 			}
-
 
 			/******************
 			*  @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (Overrun
@@ -537,12 +548,11 @@
 	}
 }
 
-
-int32_t update_tail(UART_HandleTypeDef *huart,uint32_t len)
+int32_t update_tail(UART_HandleTypeDef *huart, uint32_t len)
 {
-	if(((huart->pRxBuffPtr->tail+len) % huart->RxXferSize)<= huart->pRxBuffPtr->head)
+	if (((huart->pRxBuffPtr->tail + len) % huart->RxXferSize) <= huart->pRxBuffPtr->head)
 	{
-		huart->pRxBuffPtr->tail=((huart->pRxBuffPtr->tail+len) % huart->RxXferSize);
+		huart->pRxBuffPtr->tail = ((huart->pRxBuffPtr->tail + len) % huart->RxXferSize);
 		return 0;
 	}
 	return -1;
@@ -550,18 +560,107 @@
 
 void debug_buffer(UART_HandleTypeDef *huart)
 {
-	uint32_t i=huart->pRxBuffPtr->tail;
-	uint8_t *buffer=huart->pRxBuffPtr->buffer;
-	uint32_t flag=0;
-	while(((huart->RxXferSize+huart->pRxBuffPtr->head-i)%huart->RxXferSize)>0)
-	{
-		flag=1;
-		Uart_write(buffer[i],__CONSOLE);
-		i=((i+1)%huart->RxXferSize);
+	uint32_t i = huart->pRxBuffPtr->tail;
+	uint8_t *buffer = huart->pRxBuffPtr->buffer;
+	uint32_t flag = 0;
+	while (((huart->RxXferSize + huart->pRxBuffPtr->head - i) % huart->RxXferSize) > 0)
+	{
+		flag = 1;
+		Uart_write(buffer[i], __CONSOLE);
+		i = ((i + 1) % huart->RxXferSize);
 	}
-	if(flag == 1)
+	if (flag == 1)
 	{
-		Uart_write('\n',__CONSOLE);
+		Uart_write('\n', __CONSOLE);
+	}
+}
+
+
+/******** later added ********/
+
+
+
+void DRV_USART_INIT(USART_TypeDef* usart)
+{	
+	/*****Modify according to your need *****/
+
+	RCC->APB1ENR |= (1<<17); //enable UART 2
+	RCC->AHB1ENR |= (1<<0); //enable GPIOA clock
+	
+		
+	//2. Configure UART pin for Alternate function
+	GPIOA->MODER |= (2<<4); //bits [5:4] -> 1:0 -->Alternate function for pin PA2
+	GPIOA->MODER |= (2<<6); //bits [7:6] -> 1:0 -->Alternate function for PA3
+	
+	GPIOA->OSPEEDR |= (3<<4) | (3<<6); //bits [5:4] -> 1:1 -> high speed PA2; bits [7:6] -> 1:1 -> high speed PA3 
+	
+	GPIOA->AFR[0] |= (7<<8);//Bytes (11:10:09:08) = 0:1:1:1 --> AF7 Alternate function for USART2 at pin PA2
+	GPIOA->AFR[0] |= (7<<12); //Bytes (15:14:13:12) = 0:1:1:1 --> AF7 Alternate function for USART2 at pin PA3
+	
+	//3. Enable UART on USART_CR1 rgister
+	USART2->CR1 = 0x00; //clear USART
+	USART2->CR1 |= (1<<13);  // UE-bit enable USART
+	
+	//4. Program M bit in USART CR1 to define the word length
+	USART2->CR1 &= ~(1U<<12); // set M bit  = 0 for 8-bit word length
+	
+	//5. Select the baud rate using the USART_BRR register.
+	USART2->BRR |= (7<<0) | (24<<4); //115200
+	
+	//  6. Enable transmission TE and recieption bits in USART_CR1 register
+	USART2->CR1 |= (1<<2); // enable RE for receiver 
+	USART2->CR1 |= (1<<3); //enable TE for transmitter
+}
+/*****Modify according to your need *****/
+void UART_SendChar(USART_TypeDef *usart,uint8_t c){
+	usart->DR = c;
+	while(!(usart->SR & (1<<7)));
+}
+/*****Modify according to your need *****/
+void _USART_WRITE(USART_TypeDef *usart,uint8_t *s)
+{
+	while (*s) UART_SendChar(usart,*s++);
+}
+/*****Modify according to your need *****/
+uint8_t _USART_READ(USART_TypeDef* usart,uint8_t *buff,uint16_t size)
+{
+	uint8_t n=0;
+	for(uint8_t i=0;i<size;i++){
+		buff[i]=UART_GetChar(usart);
+		n=i;
 	}
+	buff[n+1] = '\0';
+	return n;
+}
+
+/*****Modify according to your need *****/
+
+uint8_t UART_GetChar(USART_TypeDef *usart){
+	uint8_t tmp;
+	while(!(usart->SR & (1<<5)));
+	tmp=(uint8_t)usart->DR;
+	return tmp;
 }
 
+uint8_t _USART_READ_STR(USART_TypeDef* usart,uint8_t *buff,uint16_t size)
+{
+	uint8_t n=0;
+	for(uint8_t i=0;i<size;i++){
+		buff[i]=UART_GetChar(usart);
+		n=i;
+		if(buff[i]=='\0' || buff[i] == '\n' || buff[i] == ' ')
+		{ 	
+			buff[i]='\0';
+			break;
+		}
+	}
+	return n;
+}
+
+
+
+
+
+
+
+/****************************/
\ No newline at end of file
diff -ruN duos24/src/kern/lib/kern/sys_init.c duos24_1/src/kern/lib/kern/sys_init.c
--- duos24/src/kern/lib/kern/sys_init.c	2025-03-20 15:35:28.989979500 +0600
+++ duos24_1/src/kern/lib/kern/sys_init.c	2025-03-20 15:16:05.645204800 +0600
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 
+ * Copyright (c) 2022
  * Computer Science and Engineering, University of Dhaka
  * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
  *
@@ -27,7 +27,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
- 
+
 #include <sys_init.h>
 #include <cm4.h>
 #include <sys_clock.h>
@@ -48,36 +48,74 @@
 
 void __sys_init(void)
 {
-	__init_sys_clock(); //configure system clock 180 MHz
-	__ISB();	
-	__enable_fpu(); //enable FPU single precision floating point unit
+	__init_sys_clock(); // configure system clock 180 MHz
+	__ISB();
+	__enable_fpu(); // enable FPU single precision floating point unit
 	__ISB();
 	NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
-	__SysTick_init(1000);	//enable systick for 1ms
-	//SYS_RTC_init();
-	SerialLin2_init(__CONSOLE,0);
-	SerialLin6_init(&huart6,0);
+	__SysTick_init(7000); // enable systick for 1ms
+	// SYS_RTC_init();
+	SerialLin2_init(__CONSOLE, 0);
+	SerialLin6_init(&huart6, 0);
 	Ringbuf_init(__CONSOLE);
 	Ringbuf_init(&huart6);
 	ConfigTimer2ForSystem();
 	__ISB();
-	#ifdef DEBUG
-	kprintf("\n************************************\r\n");
-	kprintf("Booting Machine Intelligence System 1.0 .....\r\n");
-	kprintf("Copyright (c) 2024, Prof. Mosaddek Tushar, CSE, DU\r\n");
-	kprintf("CPUID %x\n", SCB->CPUID);
-	kprintf("OS Version: 2024.1.0.0\n");
-	kprintf("Time Elapse %d ms\n",__getTime());
-	kprintf("*************************************\r\n");
-	kprintf("# ");
+
+	heap_init(); ////by faiak
+
+	__DSB();
+	__ISB();
+
+#ifdef DEBUG
+	// kprintf("\n************************************\r\n");
+	// kprintf("Booting Machine Intelligence System 1.0 .....\r\n");
+	// kprintf("Copyright (c) 2024, Prof. Mosaddek Tushar, CSE, DU\r\n");
+	// kprintf("CPUID %x\n", SCB->CPUID);
+	// kprintf("OS Version: 2024.1.0.0\n");
+	// kprintf("Time Elapse %d ms\n",__getTime());
+	// kprintf("*************************************\r\n");
+	// kprintf("# ");
 	show_system_info();
 	display_group_info();
-	#endif
+#endif
 }
 
 /*
-* Do not remove it is for debug purpose
-*/
+ * Do not remove it is for debug purpose
+ */
+
+/* by faiak */
+
+heap_info *heap = NULL;
+
+void heap_init(void)
+{
+
+	// Static or global declaration for heap_info
+	static heap_info heap_data; // Allocate memory for heap_info
+	heap = &heap_data;			// Initialize heap pointer to a valid address
+
+	// // Initialize heap start and metadata
+	heap->start = (heap_chunk *)&_sheap; // Point to the start of the heap
+	// heap->start->size = 0;				 // Initial size of the first chunk
+	// heap->start->isUse = 0;				 // Mark it as free
+	// heap->start->next = NULL;			 // No next chunk initially
+
+	// Calculate available heap size
+	heap->available = ((uint32_t)&_eheap - (uint32_t)&_sheap);
+
+	// Initialize the free list and current pointer
+	heap->free_list = NULL; // No free list yet
+	heap->curr = NULL;		// Current pointer points to start
+
+	// Debug output
+	kprintf("Heap start Address: %x\n", heap->start);
+	kprintf("Heap current Location: %x\n", heap->curr);
+	kprintf("Heap Capacity: %d bytes\n", heap->available);
+}
+
+/************/
 
 void SYS_ROUTINE(void)
 {
@@ -85,11 +123,10 @@
 }
 
 /*
-* Display your Full Name, Registration Number and Class Roll
-* Each line displays a student or group member information
-*/
+ * Display your Full Name, Registration Number and Class Roll
+ * Each line displays a student or group member information
+ */
 void display_group_info(void)
 {
-	kprintf("Empty Group!! -- Update Now\n")
-
+	kprintf("Roll:1 (Faiak)\nRoll:10 (Yeamim)\nRoll:12(Abrar)\n");
 }
diff -ruN duos24/src/kern/lib/kstdio.c duos24_1/src/kern/lib/kstdio.c
--- duos24/src/kern/lib/kstdio.c	2025-03-20 15:35:28.918065900 +0600
+++ duos24_1/src/kern/lib/kstdio.c	2025-03-16 18:28:20.689950300 +0600
@@ -45,6 +45,133 @@
 * %f for floating point number
 */
 // Simplified version of printf
+// void kprintf(char *format,...)
+// {
+// //write your code here
+// 	char *tr;
+// 	uint32_t i;
+// 	uint8_t *str;
+// 	va_list list;
+// 	double dval;
+// 	//uint32_t *intval;
+// 	va_start(list,format);
+// 	for(tr = format;*tr != '\0';tr++)
+// 	{
+// 		while(*tr != '%' && *tr!='\0')
+// 		{
+// 			Uart_write(*tr,__CONSOLE);
+// 			tr++;
+// 		}
+// 		if(*tr == '\0') break;
+// 		tr++;
+// 		switch (*tr)
+// 		{
+// 		case 'c': i = va_arg(list,int);
+// 			Uart_write(i,__CONSOLE);
+// 			break;
+// 		case 'd': i = va_arg(list,int);
+// 			if(i<0)
+// 			{
+// 				Uart_write('-',__CONSOLE);
+// 				i=-i;				
+// 			}
+// 			Uart_sendstring((char*)convert(i,10),__CONSOLE);
+// 			break;
+// 		case 'o': i = va_arg(list,int);
+// 			if(i<0)
+// 			{
+// 				Uart_write('-',__CONSOLE);
+// 				i=-i;				
+// 			}
+// 			Uart_sendstring((char*)convert(i,8),__CONSOLE);
+// 			break;
+// 		case 'x': i = va_arg(list,int);
+// 			/*if(i<0)
+// 			{
+// 				Uart_write('-',__CONSOLE);
+// 				i=-i;				
+// 			}*/
+// 			Uart_sendstring((char*)convertu32(i,16),__CONSOLE);
+// 			break;
+// 		case 'u':	
+// 		case 's': str = va_arg(list,uint8_t*);
+// 			Uart_sendstring((char*)str,__CONSOLE);
+// 			break;
+// 		case 'f': 
+// 			dval = va_arg(list,double);
+// 			Uart_sendstring((char*)float2str(dval),__CONSOLE);
+// 			break;	
+// 		default:
+// 			break;
+// 		}
+// 	}
+// 	va_end(list);
+// }
+
+// void putstr(const uint8_t *str,size_t size)
+// {
+// 	for(uint32_t i=0;i<size;i++)
+// 	{
+// 		Uart_write(str[i],__CONSOLE);
+// 	}
+// }
+
+// // Simplified version of scanf
+// void kscanf(char *format,...)
+// {
+// //write your code here
+// 	va_list list;
+// 	char *ptr;
+// 	uint8_t buff[50];
+// 	uint8_t *str;
+// 	int len;
+// 	ptr=format;
+// 	va_start(list,format);
+// 	while (*ptr)
+// 	{
+// 		if(*ptr == '%') //looking for format of an input
+// 		{
+// 			ptr++;
+// 			switch (*ptr)
+// 			{
+// 			case 'c': //charater
+// 				*(uint8_t*)va_arg(list,uint8_t*)=Uart_read(__CONSOLE);
+// 				break;
+// 			case 'd': //integer number 
+// 				//uart_USART_READ_STR(USART2,buff,50); 
+// 				*(uint32_t*)va_arg(list,uint32_t*)=__str_to_num(buff,10);	
+// 				break;
+// 			case 's': //string without spaces
+// 				//_USART_READ_STR(USART2,buff,50); 
+// 				str = va_arg(list,uint8_t*);
+// 				len = __strlen(buff);
+// 				for(int u = 0; u<=len; u++)	// copy from buff to user defined char pointer (i.e string)
+// 					str[u] = buff[u];	
+// 				break;
+// 			case 'x': //hexadecimal number
+// 				//_USART_READ_STR(USART2,buff,50); 
+// 				*(int*)va_arg(list,uint32_t*)=__str_to_num(buff,16);	
+// 				break;	
+// 			case 'o': //octal number
+// 				//_USART_READ_STR(USART2,buff,50); 
+// 				*(uint32_t*)va_arg(list,uint32_t*)=__str_to_num(buff,8);	
+// 				break;	
+// 			case 'f': //floating point number
+// 				//_USART_READ_STR(USART2,buff,50);
+// 				//*(uint32_t*)va_arg(list,double*) = __str_to_num(buff,10);
+// 				*(float*)va_arg(list,float*) = str2float(buff);	// Works for float but not for double !!!
+// 				break;	
+// 			default: //rest not recognized
+// 				break;
+// 			}
+// 		}
+// 		ptr++;
+// 	}
+// 	va_end(list);
+// }
+
+
+
 void kprintf(char *format,...)
 {
 //write your code here
@@ -55,51 +182,51 @@
 	double dval;
 	//uint32_t *intval;
 	va_start(list,format);
+
 	for(tr = format;*tr != '\0';tr++)
 	{
 		while(*tr != '%' && *tr!='\0')
 		{
-			Uart_write(*tr,__CONSOLE);
-			tr++;
+		UART_SendChar(USART2,*tr);
+		tr++;
 		}
 		if(*tr == '\0') break;
 		tr++;
 		switch (*tr)
 		{
 		case 'c': i = va_arg(list,int);
-			Uart_write(i,__CONSOLE);
+			UART_SendChar(USART2,i);
 			break;
 		case 'd': i = va_arg(list,int);
 			if(i<0)
 			{
-				Uart_write('-',__CONSOLE);
+				UART_SendChar(USART2,'-');
 				i=-i;				
 			}
-			Uart_sendstring((char*)convert(i,10),__CONSOLE);
+			_USART_WRITE(USART2,(uint8_t*)convert(i,10));
 			break;
 		case 'o': i = va_arg(list,int);
 			if(i<0)
 			{
-				Uart_write('-',__CONSOLE);
+				UART_SendChar(USART2,'-');
 				i=-i;				
 			}
-			Uart_sendstring((char*)convert(i,8),__CONSOLE);
+			_USART_WRITE(USART2,(uint8_t*)convert(i,8));
 			break;
 		case 'x': i = va_arg(list,int);
-			/*if(i<0)
+			if(i<0)
 			{
-				Uart_write('-',__CONSOLE);
+				UART_SendChar(USART2,'-');
 				i=-i;				
-			}*/
-			Uart_sendstring((char*)convertu32(i,16),__CONSOLE);
+			}
+			_USART_WRITE(USART2,(uint8_t*)convert(i,16));
 			break;
-		case 'u':	
 		case 's': str = va_arg(list,uint8_t*);
-			Uart_sendstring((char*)str,__CONSOLE);
+			_USART_WRITE(USART2,str);
 			break;
 		case 'f': 
 			dval = va_arg(list,double);
-			Uart_sendstring((char*)float2str(dval),__CONSOLE);
+			_USART_WRITE(USART2,(uint8_t*)float2str(dval));
 			break;	
 		default:
 			break;
@@ -108,60 +235,49 @@
 	va_end(list);
 }
 
-void putstr(const uint8_t *str,size_t size)
-{
-	for(uint32_t i=0;i<size;i++)
-	{
-		Uart_write(str[i],__CONSOLE);
-	}
-}
-
 // Simplified version of scanf
-void kscanf(char *format,...)
+void  kscanf(char *format,...)
 {
 //write your code here
 	va_list list;
 	char *ptr;
 	uint8_t buff[50];
-	uint8_t *str;
-	int len;
 	ptr=format;
 	va_start(list,format);
 	while (*ptr)
 	{
+		/* code */
 		if(*ptr == '%') //looking for format of an input
 		{
 			ptr++;
 			switch (*ptr)
 			{
-			case 'c': //charater
-				*(uint8_t*)va_arg(list,uint8_t*)=Uart_read(__CONSOLE);
+			case /* constant-expression */ 'c': //charater
+				/* code */
+				*(uint8_t*)va_arg(list,uint8_t*)=UART_GetChar(USART2);
 				break;
 			case 'd': //integer number 
-				//uart_USART_READ_STR(USART2,buff,50); 
+				_USART_READ_STR(USART2,buff,50); 
 				*(uint32_t*)va_arg(list,uint32_t*)=__str_to_num(buff,10);	
 				break;
-			case 's': //string without spaces
-				//_USART_READ_STR(USART2,buff,50); 
-				str = va_arg(list,uint8_t*);
-				len = __strlen(buff);
-				for(int u = 0; u<=len; u++)	// copy from buff to user defined char pointer (i.e string)
-					str[u] = buff[u];	
+			case 's': //need to update -- string
+				_USART_READ_STR(USART2,buff,50); 
+				*(uint32_t*)va_arg(list,uint32_t*)=__str_to_num(buff,10);	
 				break;
 			case 'x': //hexadecimal number
-				//_USART_READ_STR(USART2,buff,50); 
-				*(int*)va_arg(list,uint32_t*)=__str_to_num(buff,16);	
+				_USART_READ_STR(USART2,buff,50); 
+				*(uint32_t*)va_arg(list,uint32_t*)=__str_to_num(buff,16);	
 				break;	
 			case 'o': //octal number
-				//_USART_READ_STR(USART2,buff,50); 
+				_USART_READ_STR(USART2,buff,50); 
 				*(uint32_t*)va_arg(list,uint32_t*)=__str_to_num(buff,8);	
 				break;	
 			case 'f': //floating point number
-				//_USART_READ_STR(USART2,buff,50);
-				//*(uint32_t*)va_arg(list,double*) = __str_to_num(buff,10);
-				*(float*)va_arg(list,float*) = str2float(buff);	// Works for float but not for double !!!
+				_USART_READ_STR(USART2,buff,50); 
+				*(uint32_t*)va_arg(list,double*)=__str_to_num(buff,10);	
 				break;	
 			default: //rest not recognized
+				
 				break;
 			}
 		}
@@ -169,3 +285,4 @@
 	}
 	va_end(list);
 }
+
diff -ruN duos24/src/kern/lib/kunistd.c duos24_1/src/kern/lib/kunistd.c
--- duos24/src/kern/lib/kunistd.c	2025-03-20 15:35:28.901290900 +0600
+++ duos24_1/src/kern/lib/kunistd.c	2025-03-16 18:28:20.674317600 +0600
@@ -30,3 +30,281 @@
 #include <kunistd.h>
 /* Add your functions here */
 
+void __sys_start_task(uint32_t psp)
+{
+	asm volatile ("MOV R0, %0"
+		:
+		:"r" (psp)
+	);
+	asm volatile ("LDMIA R0!,{R4-R11}");
+	asm volatile ("MSR PSP, R0");
+	asm volatile ("ISB 0xf" ::: "memory");
+	asm volatile ("MOV LR, 0xFFFFFFFD"); ///why this line is needed?
+	asm volatile ("BX LR");
+}
+
+
+int __sys_fork(uint32_t* parents_psp){
+
+	uint32_t psp_stack_for_child[1024];
+
+	uint32_t* psp_for_child = psp_stack_for_child + 1024;
+
+	// kprintf("next pc: %x\n", next_pc);
+
+	// __sys_start_task((uint32_t)parents_psp);
+
+	// asm volatile ("MOV R0, %0"
+	// 	:
+	// 	:"r" ((uint32_t)parents_psp)
+	// );
+
+	// asm volatile ("MSR PSP, R0");
+	// asm volatile ("ISB 0xf" ::: "memory");
+	// asm volatile ("MOV LR, 0xFFFFFFFD"); ///why this line is needed?
+	// asm volatile ("BX LR");
+
+	
+
+	// kprintf("psp_child_stack: %x\n", READY_QUEUE[CURR_TASK_P + 1].psp);
+
+	// kprintf("psp_parent_stack: %x\n", READY_QUEUE[CURR_TASK_P].psp);
+
+	// kprintf("psp_for_parent svc: %x\n", parents_psp );
+
+	parents_psp[0] = TASK_ID + 1 ; //parents return child id
+
+	TCB_TypeDef* tcb = (TCB_TypeDef*)(READY_QUEUE + CURR_TASK_P + 1);
+	tcb->magic_number = MAGIC_NUMBER;
+	tcb->task_id = TASK_ID;
+	TASK_ID++;
+	kprintf("task_id: %d\n", tcb->task_id);
+
+	tcb->status = READY;
+	tcb->execution_time = 0;
+	tcb->waiting_time = 0;
+	tcb->digital_sinature = DIGITAL_SIGNATURE;
+
+	tcb->psp = psp_for_child;
+
+	*(--tcb->psp) = parents_psp[7];      // xPSR
+	*(--tcb->psp) = (uint32_t)parents_psp[6]; // PC
+	*(--tcb->psp) = parents_psp[5];      // LR
+	*(--tcb->psp) = parents_psp[4];      // R12
+	*(--tcb->psp) = parents_psp[3];      // R3
+	*(--tcb->psp) = parents_psp[2];      // R2
+	*(--tcb->psp) = parents_psp[1];      // R1
+	*(--tcb->psp) = 0;      			 // R0 ... child returns 0
+
+	for(uint32_t i = 0; i < 8; i++)
+	{
+		*(--tcb->psp) = 0;
+	}
+
+	// *(--tcb->psp) = parents_psp[15];      // r4
+	// *(--tcb->psp) = parents_psp[14]; 	// r5
+	// *(--tcb->psp) = parents_psp[13];      // r6
+	// *(--tcb->psp) = parents_psp[12];      // R7
+	// *(--tcb->psp) = parents_psp[11];      // R8
+	// *(--tcb->psp) = parents_psp[10];      // R9
+	// *(--tcb->psp) = parents_psp[9];      // R10
+	// *(--tcb->psp) = parents_psp[8];      			 // R11
+
+	// kprintf("psp_child_stack: %x\n", READY_QUEUE[CURR_TASK_P + 1].psp);
+
+	// kprintf("psp_parent_stack: %x\n", parents_psp);
+
+	QUEUE_SIZE_P++;
+
+	__DSB();
+	__ISB();
+
+	
+	// SCB->ICSR |= (1 << 27) ; // Clear all pending interrupts
+	SCB->ICSR |= (1 << 28) ; // set PendSV bit
+
+	kprintf("forked\n");
+
+	return tcb->task_id;
+
+}
+
+
+
+void* heap_malloc(uint32_t size)
+{
+    if (size == 0)
+    {
+        return NULL; // Cannot allocate zero size
+    }
+
+    // Ensure size is aligned to 8 bytes
+    size = (size + 7) & ~7;
+
+    if (size > heap->available)
+    {
+        kprintf("Heap is full or requested size too large\n");
+        return NULL;
+    }
+
+	if(heap->free_list != NULL){
+		heap_chunk* temp = heap->free_list;
+		heap_chunk* prev_temp = NULL;
+
+		while(temp != NULL){
+			if((temp->size - sizeof(heap_chunk)) >= size && temp->isUse == 0){
+
+				temp->isUse = 1;
+				heap->available -= size;
+				
+
+				if(prev_temp == NULL){
+					heap->free_list = temp->next;
+
+					if(heap->curr == NULL){
+						heap->curr = temp;
+						
+					}
+					else{
+						heap->curr->next = temp;
+						temp->next = NULL;
+						heap->curr = temp;
+					}
+				}
+				else{
+					prev_temp->next = temp->next;
+
+					if(heap->curr == NULL){
+						heap->curr = temp;
+						
+					}
+					else{
+						heap->curr->next = temp;
+						temp->next = NULL;
+						heap->curr = temp;
+					}
+
+				}
+
+				uint32_t address = (uint32_t)((uint8_t *)heap->curr + sizeof(heap_chunk));
+
+				kprintf("Allocated %d bytes at address %x from freelist\n", heap->curr->size - sizeof(heap_chunk), address);
+				kprintf("Available heap size: %d bytes\n", heap->available);
+				
+				return (void *)(address);
+			}
+			prev_temp = temp;
+			temp = temp->next;
+		}
+	}
+
+	if(((uint8_t*)heap->curr + size + sizeof(heap_chunk)) >= (uint8_t*)&_eheap){
+		kprintf("Heap is full or requested size too large\n");
+		return NULL;
+	}
+
+    if (heap->curr == NULL)
+    {
+
+        // heap_chunk *newChunk = (heap_chunk *)((uint8_t *)heap->start + sizeof(heap_chunk) + size);
+        heap_chunk *newChunk = (heap_chunk *)((uint8_t *)heap->start);
+        newChunk->size = size + sizeof(heap_chunk); 
+        newChunk->isUse = 1;
+        newChunk->next = NULL;
+
+        heap->curr = newChunk;
+    }
+    else
+    {
+
+        heap_chunk *newChunk = (heap_chunk *)((uint8_t *)heap->curr + heap->curr->size);
+        newChunk->size = size + sizeof(heap_chunk);
+        newChunk->isUse = 1;
+        newChunk->next = NULL;
+
+        heap->curr->next = newChunk;
+        heap->curr = newChunk;
+    }
+
+    heap->available -= size + sizeof(heap_chunk);
+
+    uint32_t address = (uint32_t)((uint8_t *)heap->curr + sizeof(heap_chunk));
+
+    kprintf("Allocated %d bytes at address %x\n", size, address);
+    kprintf("Available heap size: %d bytes\n", heap->available);
+
+    return (void *)(address);
+}
+
+
+
+void heap_free(void *ptr)
+{
+    if (ptr == NULL)
+    {
+        return;
+    }
+
+    heap_chunk *chunk = (heap_chunk *)((uint8_t *)ptr - sizeof(heap_chunk)); // chunk who allocated the size
+
+    kprintf("memory to free --heap_free : %x\n", chunk);
+
+    if (chunk->isUse)
+    {
+        chunk->isUse = 0;
+    }
+
+    uint8_t* start = (uint8_t*)chunk + sizeof(heap_chunk);
+	uint32_t size = chunk->size - sizeof(heap_chunk);
+
+	int i=0;
+
+	while(i < size){
+		*start = 0;
+		start++;
+		i++;
+	}
+
+	chunk->next = heap->free_list;
+	heap->free_list = chunk;
+
+	kprintf("Freed %d bytes at address %x\n", size, (uint32_t)ptr);
+	kprintf("Available heap size: %d bytes\n", heap->available);
+}
+
+
+
+int __sys_execv(char *filename, char *argv[], char *envp[]){
+	kprintf("inside execv\n");
+
+	//doing nothing with argv and envp
+
+	file_entry_t file = file_list[find_file(filename)];
+
+	if(file.address == NULL){
+		kprintf("file not found\n");
+		return -1;
+	}
+
+	void (*func_ptr)(void) = (void (*)(void)) file.address;
+
+	TCB_TypeDef* tcb = (TCB_TypeDef*)(READY_QUEUE + CURR_TASK_P);
+
+	uint64_t psp_stack[1024];
+    tcb->psp = psp_stack + 1024;
+    *(--tcb->psp) = 0x01000000;      // xPSR
+    *(--tcb->psp) = (uint32_t)func_ptr; // PC
+    *(--tcb->psp) = 0xFFFFFFFD;      // LR
+
+    for (uint32_t i = 0; i < 13; i++)
+    {
+        *(--tcb->psp) = 0;
+    }
+
+	__sys_start_task((uint32_t)tcb->psp);
+
+
+    __ISB();
+
+	return 0;
+}
\ No newline at end of file
diff -ruN duos24/src/kern/syscall/syscall.c duos24_1/src/kern/syscall/syscall.c
--- duos24/src/kern/syscall/syscall.c	2025-03-20 15:35:29.411214200 +0600
+++ duos24_1/src/kern/syscall/syscall.c	2025-03-16 18:40:14.214067000 +0600
@@ -1,61 +1,125 @@
-/*
- * Copyright (c) 2022 
- * Computer Science and Engineering, University of Dhaka
- * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
-*/
-
-#include <syscall.h>
-#include <syscall_def.h>
-#include <errno.h>
-#include <errmsg.h>
-void syscall(uint16_t callno)
+
+
+#include <sys_call.h>
+
+void syscall(uint32_t *svc_args)
 {
-/* The SVC_Handler calls this function to evaluate and execute the actual function */
-/* Take care of return value or code */
-	switch(callno)
-	{
-		/* Write your code to call actual function (kunistd.h/c or times.h/c and handle the return value(s) */
-		case SYS_read: 
-			break;
-		case SYS_write:
-			break;
-		case SYS_reboot:
-			break;	
-		case SYS__exit:
-			break;
-		case SYS_getpid:
-			break;
-		case SYS___time:
-			break;
-		case SYS_yield:
-			break;				
-		/* return error code see error.h and errmsg.h ENOSYS sys_errlist[ENOSYS]*/	
-		default: ;
+	/* The SVC_Handler calls this function to evaluate and execute the actual function */
+	/* Take care of return value or code */
+
+	uint32_t callno = ((uint8_t *)svc_args[6])[-2];
+	// kprintf("callno : %d is being called\n", callno);
+
+	switch (callno)
+	{
+	/* Write your code to call actual function (kunistd.h/c or times.h/c and handle the return value(s) */
+	case SYS_read:
+	{
+		char *format = (char *)svc_args[0];
+		va_list *args_ptr = (va_list *)svc_args[1]; // Cast to va_list pointer
+		va_list args;
+		va_copy(args, *args_ptr); // Copy contents properly
+		kscanf(format, args);
+		va_end(args);
+		break;
 	}
-/* Handle SVC return here */
-}
+	case SYS_write:
+	{
+		uint8_t fd_w = svc_args[0];
+		char *buffer_w = (char *)svc_args[1];
+		uint32_t size_w = svc_args[3];
+
+		__ISB();
+		// kprintf("fd: %d\n", fd_w);
+		// kprintf("buffer: %s\n", (char *)buffer_w);
+		// kprintf("size: %d\n", size_w);
+
+		Uart_sendstring(buffer_w, &huart2);
+		// _USART_WRITE(USART2, (uint8_t*)buffer);
+
+		break;
+	}
+	case SYS_reboot:
+	{
+		__NVIC_SystemReset();
+		break;
+	}
+	case SYS_start:
+	{
+		uint32_t psp = (uint32_t)svc_args[0];
+		__sys_start_task(psp);
+		break;
+	}
+	case SYS__exit:
+	{
+		TCB_TypeDef *tcb_to_kill = (TCB_TypeDef *)svc_args[2];
+		tcb_to_kill->status = KILLED;
+		break;
+	}
+	case SYS_getpid:
+	{
+		int pid = READY_QUEUE[CURR_TASK_P].task_id;
+		svc_args[0] = pid;
+		break;
+	}
+	case SYS___time:
+	{
+		uint32_t time = __getTime();
+		svc_args[0] = time;
+		kprintf("Time in syscall: %d\n", time);
+		break;
+	}
+	case SYS_yield:
+	{
+		// SCB->ICSR |= (1 << 27); // Clear all pending interrupts
+		SCB->ICSR |= (1 << 28); // set PendSV bit
+		break;
+	}
+	case SYS_set_pending:
+	{
+		uint8_t value = (uint8_t)svc_args[0];
+		__set_pending(value);
+		break;
+	}
+	case SYS_fork:
+	{
+		int pid = __sys_fork(svc_args);
+		svc_args[2] = pid;
+		break;
+	}
+	case SYS_malloc:
+	{
+		uint32_t size_m = svc_args[2];
+		void *ptr = heap_malloc(size_m);
+		kprintf("Malloc ptr: %x\n", ptr);
+		svc_args[2] = (uint32_t)ptr;
+		break;
+	}
+	case SYS_free:
+	{
+		void *ptr1 = (void *)svc_args[2];
+
+		kprintf("memory to free --syscall : %x\n", ptr1);
+		heap_free(ptr1);
 
+		*(&ptr1) = NULL;
+		break;
+	}
+	case SYS_execv:
+	{
+		char *filename = (char *)svc_args[0];
+		char **argv = (char **)svc_args[1];
+		char **envp = (char **)svc_args[2];
+		int val = __sys_execv(filename, argv, envp);
+		svc_args[0] = val;
+		break;
+	}
+	/* return error code see error.h and errmsg.h ENOSYS sys_errlist[ENOSYS]*/
+	default:
+	{
+		kprintf("Error: Invalid syscall number %d\n", callno);
+		break;
+	}
+	}
+	/* Handle SVC return here */
+}
diff -ruN duos24/src/userland/include/app.h duos24_1/src/userland/include/app.h
--- duos24/src/userland/include/app.h	1970-01-01 06:00:00.000000000 +0600
+++ duos24_1/src/userland/include/app.h	2025-03-16 19:05:58.119802000 +0600
@@ -0,0 +1,4 @@
+#include <unistd.h>
+#include <times.h>
+
+int umain();
diff -ruN duos24/src/userland/include/times.h duos24_1/src/userland/include/times.h
--- duos24/src/userland/include/times.h	2025-03-20 15:35:30.179126100 +0600
+++ duos24_1/src/userland/include/times.h	2025-03-16 19:05:39.038551500 +0600
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 
+ * Copyright (c) 2022
  * Computer Science and Engineering, University of Dhaka
  * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
  *
@@ -27,8 +27,24 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
- 
+
 #ifndef __TIMES_H
 #define __TIMES_H
 /* Define times function prototypes here */
+
+#include <stdint.h>
+#include <syscall_def.h>
+#include <types.h>
+
+uint32_t du_getSystickTime(void);
+
+void du_reboot(void);
+
+void *du_malloc(uint32_t size);
+
+void du_free(void *ptr);
+
+void fopen(char *name, uint8_t t_access, uint32_t *op_addr);
+
+void fclose(uint32_t *op_addr);
 #endif
diff -ruN duos24/src/userland/include/unistd.h duos24_1/src/userland/include/unistd.h
--- duos24/src/userland/include/unistd.h	2025-03-20 15:35:30.204235700 +0600
+++ duos24_1/src/userland/include/unistd.h	2025-03-16 19:33:45.213223000 +0600
@@ -32,4 +32,14 @@
 #define __UNISTD_H
 /* Basic input and output function */
 
+#include <stdint.h>
+#include <types.h>
+#include <syscall_def.h>
+#include <stdarg.h>
+#include <kstring.h>
+#include <cm4.h>
+
+
+void du_printf(char *format, ...);
+void du_scanf(char* format, ...);
 #endif
diff -ruN duos24/src/userland/utils/app.c duos24_1/src/userland/utils/app.c
--- duos24/src/userland/utils/app.c	1970-01-01 06:00:00.000000000 +0600
+++ duos24_1/src/userland/utils/app.c	2025-03-20 15:13:56.165555500 +0600
@@ -0,0 +1,8 @@
+#include <app.h>
+
+int umain()
+{
+    du_printf("From Userland");
+
+    return 0;
+}
\ No newline at end of file
diff -ruN duos24/src/userland/utils/times.c duos24_1/src/userland/utils/times.c
--- duos24/src/userland/utils/times.c	2025-03-20 15:35:30.250581200 +0600
+++ duos24_1/src/userland/utils/times.c	2025-03-16 19:02:55.805647200 +0600
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 
+ * Copyright (c) 2022
  * Computer Science and Engineering, University of Dhaka
  * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
  *
@@ -27,7 +27,99 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
- 
+
 #include <times.h>
 /* Define you function details here */
 
+uint32_t du_getSystickTime(void)
+{
+    uint32_t time;
+
+    asm volatile(
+        "PUSH {r4-r11, ip, lr}\n"
+        "svc %0\n"
+        "POP {r4-r11, ip, lr}\n"
+        :
+        : "i"(SYS___time));
+
+    asm volatile(
+        "mov %0, r0\n"
+        : "=r"(time));
+
+    return time;
+}
+
+void du_reboot(void)
+{
+    asm volatile(
+        "PUSH {r4-r11, ip, lr}\n"
+        "svc %0\n"
+        "POP {r4-r11, ip, lr}\n"
+        :
+        : "i"(SYS_reboot));
+}
+
+void *du_malloc(uint32_t size)
+{
+    uint8_t sys_malloc = 69;
+    void *ptr;
+    __asm volatile(
+        "mov r2, %0\n"
+        "PUSH {r4-r11, ip, lr}\n"
+        "svc %1\n"
+        "POP {r4-r11, ip, lr}\n"
+        :
+        : "r"(size), "i"(SYS_malloc));
+
+    __asm volatile(
+        "mov %0, r2\n"
+        : "=r"(ptr));
+
+    return ptr;
+}
+
+void du_free(void *ptr)
+{
+
+    kprintf("memory to free --times : %x\n", ptr);
+    asm volatile(
+        "mov r2, %0\n"
+        "PUSH {r4-r11, ip, lr}\n"
+        "svc %1\n"
+        "POP {r4-r11, ip, lr}\n"
+        :
+        : "r"(ptr), "i"(SYS_free));
+
+    ptr = NULL;
+    kprintf("memory to free --times : %x\n", ptr);
+}
+
+void fopen(char *name, uint8_t t_access, uint32_t *op_addr)
+{
+    __asm volatile(
+        "mov r0, %[x]\n"
+        "mov r1, %[y]\n"
+        :
+        : [x] "r"(name), [y] "r"(t_access));
+    __asm volatile(
+        "mov r2, %[x]\n"
+        :
+        : [x] "r"(op_addr));
+
+    __asm volatile("PUSH {r4-r11, ip, lr}");
+    __asm volatile("svc %0" : : "i"(SYS_open));
+
+    __asm volatile("POP {r4-r11, ip, lr}");
+}
+
+void fclose(uint32_t *op_addr)
+{
+    __asm volatile(
+        "mov r0, %[x]\n"
+        :
+        : [x] "r"(op_addr));
+    __asm volatile("PUSH {r4-r11, ip, lr}");
+    __asm volatile("svc %0" : : "i"(SYS_close));
+
+    __asm volatile("POP {r4-r11, ip, lr}");
+}
\ No newline at end of file
diff -ruN duos24/src/userland/utils/unistd.c duos24_1/src/userland/utils/unistd.c
--- duos24/src/userland/utils/unistd.c	2025-03-20 15:35:30.226950900 +0600
+++ duos24_1/src/userland/utils/unistd.c	2025-03-16 19:33:35.124334100 +0600
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 
+ * Copyright (c) 2022
  * Computer Science and Engineering, University of Dhaka
  * Credit: CSE Batch 25 (starter) and Prof. Mosaddek Tushar
  *
@@ -27,7 +27,157 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
- 
+
 #include <unistd.h>
 /* Write your highlevel I/O details */
 
+void du_scanf(char *format, ...)
+{
+    va_list args;
+    va_start(args, format);
+
+    __asm volatile(
+        "mov r0, %0\n"
+        "mov r1, %1\n"
+        :
+        : "r"(format), "r"(&args));
+
+    __asm volatile("PUSH {r4-r11}");
+    __asm volatile(
+        "svc %0\n"
+        "POP {r4-r11}\n"
+        :
+        : "i"(SYS_read));
+
+    va_end(args);
+}
+
+void du_printf(char *format, ...)
+{
+    uint8_t str[500];
+    int index = 0;
+    va_list(place_holders);
+
+    va_start(place_holders, format);
+
+    int i = 0;
+    while (format[i] != '\0')
+    {
+        if (format[i] == '%')
+        {
+            i++;
+            if (format[i] == 'd')
+            {
+                int num = va_arg(place_holders, int);
+                if (num < 0)
+                {
+                    str[index] = '-';
+                    index++;
+                    num = -num;
+                }
+                uint8_t *result = convert(num, 10);
+
+                for (result; *result != '\0'; result++)
+                {
+                    str[index] = *result;
+                    index++;
+                }
+            }
+            else if (format[i] == 'c')
+            {
+                uint8_t ch = va_arg(place_holders, int);
+
+                str[index] = ch;
+                index++;
+            }
+            else if (format[i] == 's')
+            {
+                uint8_t *s = va_arg(place_holders, uint8_t *);
+                for (s; *s != '\0'; s++)
+                {
+                    str[index] = *s;
+                    index++;
+                }
+            }
+            else if (format[i] == 'f')
+            {
+                double num = va_arg(place_holders, double);
+
+                // uint8_t* result = float_2_str(num);
+                uint8_t *result = float2str(num);
+                for (result; *result != '\0'; result++)
+                {
+                    str[index] = *result;
+                    index++;
+                }
+            }
+            else if (format[i] == 'x')
+            {
+                int num = va_arg(place_holders, int);
+                if (num < 0)
+                {
+                    str[index] = '-';
+                    index++;
+                    num = -num;
+                }
+
+                str[index] = '0';
+                index++;
+                str[index] = 'x';
+                index++;
+
+                uint8_t *result = convert(num, 16);
+                for (result; *result != '\0'; result++)
+                {
+                    str[index] = *result;
+                    index++;
+                }
+            }
+        }
+        else
+        {
+
+            str[index] = (uint8_t)format[i];
+            index++;
+        }
+        i++;
+    }
+
+    str[index] = '\0';
+
+    va_end(place_holders);
+
+    volatile uint8_t fd = 1;
+    volatile char *buffer = (uint8_t *)str;
+    volatile uint32_t size_x = index;
+
+    // kprintf("format: %s\n", format);
+
+    // kprintf("fd: %d\n", fd);
+    // kprintf("buffer: %s\n", (char *)buffer);
+    // kprintf("size: %d\n", size_x);
+
+    __asm volatile(
+        "mov r0, %0\n" : : "r"(fd));
+    __asm volatile(
+        "mov r1, %0\n" : : "r"(buffer));
+    __asm volatile(
+        "mov r2, %0\n" : : "r"(size_x));
+
+    __ISB();
+
+    // int x = 0;
+    // asm volatile("mov %0, r3\n"
+    //              : "=r"(x));
+    // kprintf("x: %d\n", x);
+
+    __DSB();
+    __ISB();
+
+    asm volatile("PUSH {r4-r11}");
+    asm volatile(
+        "svc %0\n"
+        "POP {r4-r11}\n"
+        :
+        : "i"(SYS_write));
+}
\ No newline at end of file
